[
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introducción a R",
    "section": "",
    "text": "1.1 Instalando  y R Studio\nR Studio es un entorno de desarrollo integrado (IDE por sus siglas en inglés), con varias herramientas que permiten utilizar los lenguajes de programación R y python, ambas utilizadas ampliamente en la ciencia de datos. Este software provee una interfaz intuitiva que permite un manejo fácil y amigable de cualquier tipo de datos. Tanto R como R Studio son de código abierto y pueden descargarse gratuitamente.\nActualmente, existen dos alternativas para utilizar R Studio. Este puede instalarse localmente en un computador, o puedes utilizarlo en la web a través de Posit Cloud. Esta última opción es muy útil si tu computador no cuenta con suficiente memoria RAM. Crear una cuenta en Posit cloud es gratis y puedes crear hasta 25 proyectos. Para hacerlo solamente sigue este enlace, haz clic en Sign up, y sigue las instrucciones.\nUna vez hayas creado tu cuenta, verás una ventana como la siguiente y puedes crear un nuevo proyecto:\nPor el contrario, si quieres tener R y R Studio en tu computador debes contar con acceso a internet y cualquier navegador web de tu preferencia, Chrome, Firefox, etc. Si tu Sistema Operativo es Windows la descarga de R debe hacerse desde el subdirectorio base en la web de CRAN (Comprehensive R Archive Network), aquí. De la misma manera, R Studio para Windows puede ser descargado desde aquí. Si surge algún problema durante la instalación o quieres saber más sobre R, puedes dirigirte a la sección de Preguntas frecuentes.\nSi tienes otro Sistema Operativo o tienes un nivel medio o avanzado en el uso de R, te recomiendo leer este tutorial de instalación.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Resumen",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Resumen</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literatura citada",
    "section": "",
    "text": "Abrahms, Briana, Ellen O. Aikens, Jonathan B. Armstrong, William W.\nDeacy, Matthew J. Kauffman, and Jerod A. Merkle. 2021. “Emerging\nPerspectives on Resource Tracking\nand Animal Movement\nEcology.” Trends in Ecology & Evolution\n36 (4): 308–20. https://doi.org/10.1016/j.tree.2020.10.018.\n\n\nGurarie, Eliezer, Chloe Bracis, Maria Delgado, Trevor D. Meckley, Ilpo\nKojola, and C. Michael Wagner. 2016. “What Is the Animal Doing?\nTools for Exploring Behavioural Structure in Animal\nMovements.” Journal of Animal Ecology 85 (1): 69–84. https://doi.org/10.1111/1365-2656.12379.\n\n\nKays, Roland, Margaret C. Crofoot, Walter Jetz, and Martin Wikelski.\n2015. “Terrestrial Animal Tracking as an Eye on Life and\nPlanet.” Science 348 (6240): aaa2478. https://doi.org/10.1126/science.aaa2478.\n\n\nPretorius, Mattheuns, Lourens Leeuwner, Gareth Tate, Andre Botha,\nMichael Michael, Kaajial Durgapersad, and Kishaylin Chetty. 2020.\n“Movement Patterns of Lesser Flamingos Phoeniconaias\nMinor: Nomadism or Partial Migration?” Wildlife Biology.\nhttps://doi.org/10.2981/wlb.00728.\n\n\nSilva, Inês, Christen H. Fleming, Michael J. Noonan, Jesse Alston, Cody\nFolta, William F. Fagan, and Justin M. Calabrese. 2022.\n“Autocorrelation-Informed Home Range Estimation: A\nReview and Practical Guide.” Methods in Ecology and\nEvolution 13 (3): 534–44. https://doi.org/10.1111/2041-210X.13786.",
    "crumbs": [
      "Literatura citada"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introducción a la Telemetría de Grandes Mamíferos",
    "section": "",
    "text": "Inicio\nEsta es la sexta edición del curso de Introduccion a la Ecología y Telemetria de Grandes Mamiferos dictado por la Fundación Oso Andino. Puedes enterarte sobre el cronograma de actividades aquí.",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "intro.html#vectores",
    "href": "intro.html#vectores",
    "title": "1  Introducción a R",
    "section": "1.6 Vectores",
    "text": "1.6 Vectores\nUn vector es una secuencia de datos del mismo tipo ya sean numéricos o de carácter. Así, para construir vectores numéricos, deberemos primeramente nombrar a nuestro objeto y asignarle valores mediante &lt;-. Supongamos que quieres almacenar los resultados de las operaciones anteriores en un objeto “x” e “y”.\n\nx &lt;- log(5)\n\ny &lt;- log(5)/log2(5*3)\n\nObserva que en el panel Environment ahora hay dos objetos que corresponden a los vectores numéricos que creaste con los resultados de cada operación. De esta manera, ahora será más fácil manipular estos datos.\n\n# Ejecuta lo siguiente\nx*y\n\n# Almacena el resultado de ambos objetos en un vector nuevo\nz &lt;- x*y\n\n# Puedes imprimir el resultado en la consola\nz\n\nAhora crea una secuencia de números dentro de un vector. Una forma rápida de crear este tipo de vectores es mediante la función seq.\n\n# Puedes crear números sucesivos del 1 - 10\na &lt;- c(1:10)\n\n# O una secuencia hasta el 15 con un intervalo de 3\nb &lt;- seq(1, 15, 3)\n\nLa función seq crea secuencias en este caso del número 1 hasta el 15, con un intervalo de 3. Pero, ¿cómo podrías saber qué significa cada argumento dentro de una función si no la conoces?\nExisten dos maneras de indagar sobre una función cualquiera y obtener ayuda sobre la misma:\n\n?seq\nhelp(seq)\n\nLa sección de ayuda contiene todo lo que debes saber sobre cualquier función, al final de cada manual de instrucciones de la función podrás ver además ejemplos que te ayudarán a entenderla y aplicarla según tus necesidades.\nAhora bien, puedes aplicar esto a un ejemplo más cotidiano. Imagina que posees datos de distintos pesos de varios individuos de una especie de roedor que has capturado y quieres realizar algunas operaciones con ellos. Almacena estos pesos dentro de un vector utilizando la función concatenar c().\n\npesos &lt;- c(25, 27, 30, 20, 26, 27.5, 23, 30.8)\n\nAhora que tienes estos datos almacenados en un vector, puedes realizar operaciones con ellos.\n\n# Número de observaciones\nlength(pesos)\n\n# Valores minimo o maximo de estos datos\nmin(pesos)\nmax(pesos)\n\n# Promedio\nmean(pesos)\n\nPara hacer este ejemplo aún más real, imagina que las medidas tomadas eran erróneas o ya no sirven para su estudio. Puedes entonces modificar el vector de la siguiente manera:\n\n# Elimina el cuarto valor en nuestro vector\npesos_mod &lt;- pesos[-4]\n\n# Remueve desde el primer hasta el quinto valor\npesos_mod &lt;- pesos[-1:-5]\n\n# Agrega más valores al vector\npesos_mod &lt;- c(pesos, 21, 28.3, 31, 26.5)\n\nCuando modificas un vector es usualmente aconsejable crear uno nuevo y almacenar la nueva información en éste. El código no siempre se verá tan sencillo como en el ejemplo anterior y es mejor trabajar de una manera segura al manipular metadatos.\nEs muy útil saber que si deseas eliminar cualquier objeto, lo puedes hacer en cualquier momento mediante la función remove() o rm(). Esto es especialmente útil si estás trabajando con un set de datos muy grande y quieres liberar memoria.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#matrices",
    "href": "intro.html#matrices",
    "title": "1  Introducción a R",
    "section": "1.7 Matrices",
    "text": "1.7 Matrices\nUna matriz no es más que un conjunto de datos del mismo tipo organizado de forma bidimensional, es decir, en filas y columnas. Crear y modificar matrices tiene también un proceso parecido al de los vectores.\n\nmatriz &lt;- matrix(1:14, ncol=7)\nmatriz\n\n\n\n\n\n\n\nEjercicio\n\n\n\nOrganiza diferentes matrices con diferentes números de columnas y filas, usa help(matrix) para saber como hacerlo. ¿Qué sucede si organizas la matriz mediante matrix(2:14, ncol=3)?:\n\n\nEste método solo crea matrices con datos secuenciales, entonces ¿cómo podrías organizar distintos pesos de roedores de forma bidimensional? Siguiendo con el ejemplo de los roedores, supongamos que tienes dos especies de roedores.\n\nroedor1 &lt;- c(25, 27, 30, 20, 26, 27.5, 23, 30.8)\nroedor2 &lt;- c(26, 26.5, 30, 20, 31, 27.5, 28, 20.8)\n\n# Lee sobre cbind usando help()\nroedores &lt;- cbind(roedor1, roedor2)\n\n# Ahora utiliza rbind() para unir ambos vectores. ¿Cuál es la diferencia?\n\nAl igual que los vectores, las matrices también pueden ser modificadas. Sin embargo, al haber añadido una dimensión más a nuestros datos, la forma de escribir los códigos cambia dependiendo de si quieres modificar una fila o una columna.\n\n# Elimina la cuarta fila\nroedores_mod &lt;- roedores[-4,]\n\n# Elimina la 1ra, 2da y 7ma fila\nroedores_mod &lt;- roedores[c(-1,-2,-7),]\n\n# Ahora intenta esto\nroedores_mod &lt;- roedores[,-1]\n# ¿Qué pasó luego de ejecutar este código?\n# Observa la posición de la coma\n\n\n\n\n\n\n\nEjercicio\n\n\n\nAñade dos nuevas columnas a la matriz roedores y posteriormente elimina los datos desde la 2da hasta la 4ta fila.\n\n\nTambién puedes usar distintas funciones para analizar cualquier matriz.\n\nhead(roedores)\nnrow(roedores)\nclass(roedores)\n\nPuedes leer mas sobre estas funciones en la sección de ayuda.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#data-frames",
    "href": "intro.html#data-frames",
    "title": "1  Introducción a R",
    "section": "1.8 Data frames",
    "text": "1.8 Data frames\nUn data frame es un set de datos que puede estar conformado tanto por valores numéricos o también por caracteres. Trabajar con este tipo de objetos es una aproximación más realista debido al tipo de .\nContinuemos con nuestro ejemplo de los roedores, supongamos que quieres agregar una columna que contenga un vector de caracteres y se le asigne el nombre de especie a cada roedor. Para este propósito organizaremos los datos de pesos de los roedores en filas.\n\n# Añade varias veces los objetos creados anteriormente\nroedores &lt;- cbind(roedor1, roedor2, roedor1, roedor2)\nclass(roedores)\n## [1] \"matrix\" \"array\"\n\n#Crea un vector de caracteres\nlocalidad &lt;- c(\"Quito\", \"Guayaquil\")\n\nEl objeto roedores es aún una matriz, ¿cómo podrías añadir las localidades para convertirlo en un data frame?\n\n# Utiliza la función data.frame\nroedores &lt;- data.frame(roedores, localidad)\n\n# Analiza el data frame\nclass(roedores)\nsummary(roedores)\nstr(roedores)\n\nLa función summary y str nos brindan información relevantes que será necesaria en clases posteriores. ¿Qué pasa si quieres saber algo más específico como cuántos valores por debajo de 25 existen en el data frame?\n\nroedores &lt;= 25\n##      roedor1 roedor2 roedor1.1 roedor2.1 localidad\n## [1,]    TRUE   FALSE      TRUE     FALSE     FALSE\n## [2,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [3,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [4,]    TRUE    TRUE      TRUE      TRUE     FALSE\n## [5,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [6,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [7,]    TRUE   FALSE      TRUE     FALSE     FALSE\n## [8,]   FALSE    TRUE     FALSE      TRUE     FALSE\n\nEjecutar este código nos devuelve valores lógicos o también llamados booleanos como resultado. Cada TRUE o FALSE puede ser contado individualmente, pero ¿cómo lograrías contarlos automáticamente?\n\nsum(roedores&lt;= 25)\n#Ahora utiliza la función which(), ¿cuál es la diferencia?\n\nTambién puedes elegir columnas individuales y realizar el mismo procedimiento. El signo $ señala cual es la columna de la cual quieres tomar los datos.\n\nroedores$roedor1 &gt; 25\n\nLa manipulación de esta clase de objetos será ampliada y tratada con más detenimiento en la siguiente clase.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#listas",
    "href": "intro.html#listas",
    "title": "1  Introducción a R",
    "section": "1.6 Listas",
    "text": "1.6 Listas\nxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#dplyr-ggplot2-y-tidyverse",
    "href": "intro.html#dplyr-ggplot2-y-tidyverse",
    "title": "1  Introducción a R",
    "section": "2.1 dplyr, ggplot2 y tidyverse",
    "text": "2.1 dplyr, ggplot2 y tidyverse\nTidyverse es una colección de paquetes que contiene a dplyr y ggplot2. Estos han sido creados para facilitar la manipulación y vsualización de datos mediante gráficos estéticos con varias opciones para modificarlos y presentarlos. Puedes ver algunos ejemplos en la galería oficial de ggplot2, y varios ejemplos sobre las extensiones que han sido escritas para ampliar aún más el funcionamiento de este paquete.\nUna vez hayas activado dplyr, ya puedes buscat datos específicos en el data frame “roedores”.\n\nlibrary(dplyr)\n\n# Filtra por localidad\nfilter(roedores, localidad == \"Quito\")\n\n# Almacena los resultados en un objeto nuevo llamado capital\ncapital &lt;- filter(roedores, localidad == \"Quito\")\ncapital &lt;- select(capital, roedor2)\n\n📚 Tarea\nUtiliza todo lo aprendido en esta clase y el set de datos roedores y responde: ¿cuántos individuos de Guayaquil tienen pesos menores o iguales a 26.5?\n\n2.1.1 ggplot2\nAhora puedes visualizar los datos de una manera más atractiva y comprensible. Para ello, activa el paquete ggplot2 y ejecuta:\n\nggplot(data = roedores) +\n  geom_point(aes(x = roedor1, y = roedor2),\n             size = 5)\n\n\n\n\n\n\n\n\n📚 Tarea\nUtiliza el manual de ayuda de geom_point() para descifrar como elaboré este gráfico:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "index.html#agradecimientos",
    "href": "index.html#agradecimientos",
    "title": "Introducción a la Telemetría de Grandes Mamíferos",
    "section": "Agradecimientos",
    "text": "Agradecimientos\nEsta edición del curso ha sido auspiciada por el Instituto Nacional de Biodiversidad y la Universidad Técnica de Cotopaxi.",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "intro.html#ya-has-instalado-r-studio-y-ahora-qué",
    "href": "intro.html#ya-has-instalado-r-studio-y-ahora-qué",
    "title": "1  Introducción a R",
    "section": "1.2 !Ya has instalado R Studio! ¿Y ahora qué?",
    "text": "1.2 !Ya has instalado R Studio! ¿Y ahora qué?\nUna vez que abras R Studio notarás muchas opciones, paneles y una consola. Todo esto puede parecer confuso al principio pero ahora te familiarizarás rápidamente con esta interfaz.\nLa barra de herramientas en la parte superior contiene las opciones File, Edit, Code, View, etc. Debajo de File puedes encontrar un icono similar a este . Una vez hagas clic en este, podrás ver una amplia lista de documentos que puedes crear, entre ellos R Script. Este es el tipo de documento que utilizaremos para escribir nuestros códigos.\n\n\n\n\n\n\nNote\n\n\n\nTambién puedes crear un nuevo script presionando Ctrl+Shift+N.\n\n\n\n\n\n\n\nUna vez que hayas creado un nuevo script, R Studio lucirá de la siguiente manera:\n\n\n\n\n\nAhora puedes observar 4 paneles con varias opciones dentro de cada uno.\n\nSource es el panel en el que puedes crear y editar scripts.\nEnvironment almacena los objetos creados a lo largo del trabajo por tu script.\nEl panel que contiene a las pestañas Files, Plots, Packages, Help y Viewer, te permetirá encontrar de manera rápida y eficiente los archivos en tu directorio de trabajo (Files), los gráficos generados (Plots), los paquetes instalados (Packages), manuales de ayuda de funciones y de paquetes instalados (Help), y por último a Viewer, un panel que muestra gráficos interactivos generados por algunos paquetes.\nEn Console encontrarás el signo &gt; llamado prompt que muestra si el sistema está listo o no para ejecutar un comando. Además, los resultados de los análisis se mostrarán aquí.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#qué-es-un-script",
    "href": "intro.html#qué-es-un-script",
    "title": "1  Introducción a R",
    "section": "1.3 ¿Qué es un script?",
    "text": "1.3 ¿Qué es un script?\nUn script comprende una serie de comandos escritos en un archivo de texto que pueden ser almacenados, editados y ejecutados. ¿Suena sencillo? Efectivamente es un concepto simple y tiene muchas ventajas si se lo compara con programas que no cuentan con esta opción. Un script nos brinda la posibilidad de editar cualquier línea de comando las veces que sea necesario, te permite retomar cualquier trabajo tras varios días, meses o años. Además puedes agregar comentarios sobre el código que escribes como verás a continuación. Esto resulta extremadamente útil si quieres compartir tu trabajo con otros, o si te encuentras trabajando en un proyecto extenso, el cual podrás retomar exactamente desde donde lo dejaste.\nAhora que conoces un poco más sobre esta interfaz, ¡ya puedes empezar!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#primeros-pasos",
    "href": "intro.html#primeros-pasos",
    "title": "1  Introducción a R",
    "section": "1.4 Primeros pasos",
    "text": "1.4 Primeros pasos\nEmpecemos escribiendo operaciones matemáticas sencillas en el script.\n\n2 + 2\n\nAhora presiona Enter, ¿qué sucede? Es importante saber que la ejecución de comandos con la tecla Enter se lleva a cabo solamente en la Consola. Si quieres ejecutar un código dentro del script, debes apretar Ctrl+Enter.\nAhora escribe la misma operación precedida por un signo numeral # y presiona Ctrl+Enter.\n\n# 2 + 2\n\n¿Hay algún resultado? Si colocamos este símbolo al iniciar una línea, esta no será leída como un código, por lo que no se ejecutará. Esto es muy útil al momento de agregar comentarios sobre el código que escribimos y para poder compartirlo con otros y así entiendan rápidamente que realizaste en tu trabajo.\nSigamos intentando con más operaciones matemáticas.\n\n# División\n8/2\n\n# Multiplicación y suma\n2*2+7\n2*(2+7) #¿Este resultado es diferente?\n\n# Potenciación\n3^3\n\n# Potencia negativa\n3^-3\n\n# También puedes ejecutar varias operaciones sobre una misma línea\n3*10 ; 15/45 ; 15-37\n\nCompliquemos esto aplicando otras funciones matemáticas.\n\n# Logaritmo\nlog(5)\n\n# Logaritmo natural y base 10 con otras operaciones\nlog(5)/log2(5*3)\n\n# Raiz cuadrada\nsqrt(23.567)\n\n# Factorial\nfactorial(24)\n\nNota que los números ahora se encuentran dentro de un paréntesis y delante de una función. Existen probablemente millones de funciones en R con propósitos diferentes y específicos. Para poder ejecutarlas, éstas deben estar escritas con la estructura que viste en el ejemplo anterior función( ... ). Tú también puedes crear tus propias funciones, pero eso lo dejaremos para un curso más avanzado.\nComo lo notaste, todos los resultados de estas operaciones se muestran en la Consola. Sin embargo, si quisieras almacenarlos y manipularlos posteriormente es necesario transformarlos en objetos. Para ello debemos hablar sobre la estructura de datos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#estructura-de-datos-objetos-vectores-data-frames-y-listas.",
    "href": "intro.html#estructura-de-datos-objetos-vectores-data-frames-y-listas.",
    "title": "1  Introducción a R",
    "section": "1.5 Estructura de datos: Objetos, vectores, data frames, y listas.",
    "text": "1.5 Estructura de datos: Objetos, vectores, data frames, y listas.\nR contiene una jerarquía de elementos y provee varios tipos de estructuras de datos especializadas a las que se les conoce como objetos. Para los propósitos de este curso mencionaremos a los vectores y matrices pero nos enfocaremos en los data frames. Sin embargo, es importante saber que existen otros tipos de estructuras de datos como las listas, que utilizaremos ampliamente en el nivel avanzado de este curso.\n\n1.5.1 Vectores\nUn vector es una secuencia de datos del mismo tipo ya sean numéricos o de carácter. Así, para construir vectores numéricos, deberemos primeramente nombrar a nuestro objeto y asignarle valores mediante &lt;-. Supongamos que quieres almacenar los resultados de las operaciones anteriores en un objeto “x” e “y”.\n\nx &lt;- log(5)\n\ny &lt;- log(5)/log2(5*3)\n\nObserva que en el panel Environment ahora hay dos objetos que corresponden a los vectores numéricos que creaste con los resultados de cada operación. De esta manera, ahora será más fácil manipular estos datos.\n\n# Ejecuta lo siguiente\nx*y\n\n# Almacena el resultado de ambos objetos en un vector nuevo\nz &lt;- x*y\n\n# Puedes imprimir el resultado en la consola\nz\n\nAhora crea una secuencia de números dentro de un vector. Una forma rápida de crear este tipo de vectores es mediante la función seq.\n\n# Puedes crear números sucesivos del 1 - 10\na &lt;- c(1:10)\n\n# O una secuencia hasta el 15 con un intervalo de 3\nb &lt;- seq(1, 15, 3)\n\nLa función seq crea secuencias en este caso del número 1 hasta el 15, con un intervalo de 3. Pero, ¿cómo podrías saber qué significa cada argumento dentro de una función si no la conoces?\nExisten dos maneras de indagar sobre una función cualquiera y obtener ayuda sobre la misma:\n\n?seq\nhelp(seq)\n\nLa sección de ayuda contiene todo lo que debes saber sobre cualquier función, al final de cada manual de instrucciones de la función podrás ver además ejemplos que te ayudarán a entenderla y aplicarla según tus necesidades.\nAhora bien, puedes aplicar esto a un ejemplo más cotidiano. Imagina que posees datos de distintos pesos de varios individuos de una especie de roedor que has capturado y quieres realizar algunas operaciones con ellos. Almacena estos pesos dentro de un vector utilizando la función concatenar c().\n\npesos &lt;- c(25, 27, 30, 20, 26, 27.5, 23, 30.8)\n\nAhora que tienes estos datos almacenados en un vector, puedes realizar operaciones con ellos.\n\n# Número de observaciones\nlength(pesos)\n\n# Valores minimo o maximo de estos datos\nmin(pesos)\nmax(pesos)\n\n# Promedio\nmean(pesos)\n\nPara hacer este ejemplo aún más real, imagina que las medidas tomadas eran erróneas o ya no sirven para su estudio. Puedes entonces modificar el vector de la siguiente manera:\n\n# Elimina el cuarto valor en nuestro vector\npesos_mod &lt;- pesos[-4]\n\n# Remueve desde el primer hasta el quinto valor\npesos_mod &lt;- pesos[-1:-5]\n\n# Agrega más valores al vector\npesos_mod &lt;- c(pesos, 21, 28.3, 31, 26.5)\n\nCuando modificas un vector es usualmente aconsejable crear uno nuevo y almacenar la nueva información en éste. El código no siempre se verá tan sencillo como en el ejemplo anterior y es mejor trabajar de una manera segura al manipular metadatos.\nEs muy útil saber que si deseas eliminar cualquier objeto, lo puedes hacer en cualquier momento mediante la función remove() o rm(). Esto es especialmente útil si estás trabajando con un set de datos muy grande y quieres liberar memoria.\n\n\n1.5.2 Matrices\nUna matriz no es más que un conjunto de datos del mismo tipo organizado de forma bidimensional, es decir, en filas y columnas. Crear y modificar matrices tiene también un proceso parecido al de los vectores.\n\nmatriz &lt;- matrix(1:14, ncol=7)\nmatriz\n\n\n\n\n\n\n\nEjercicio\n\n\n\nOrganiza diferentes matrices con diferentes números de columnas y filas, usa help(matrix) para saber como hacerlo. ¿Qué sucede si organizas la matriz mediante matrix(2:14, ncol=3)?:\n\n\nEste método solo crea matrices con datos secuenciales, entonces ¿cómo podrías organizar distintos pesos de roedores de forma bidimensional? Siguiendo con el ejemplo de los roedores, supongamos que tienes dos especies de roedores.\n\nroedor1 &lt;- c(25, 27, 30, 20, 26, 27.5, 23, 30.8)\nroedor2 &lt;- c(26, 26.5, 30, 20, 31, 27.5, 28, 20.8)\n\n# Lee sobre cbind usando help()\nroedores &lt;- cbind(roedor1, roedor2)\n\n# Ahora utiliza rbind() para unir ambos vectores. ¿Cuál es la diferencia?\n\nAl igual que los vectores, las matrices también pueden ser modificadas. Sin embargo, al haber añadido una dimensión más a nuestros datos, la forma de escribir los códigos cambia dependiendo de si quieres modificar una fila o una columna.\n\n# Elimina la cuarta fila\nroedores_mod &lt;- roedores[-4,]\n\n# Elimina la 1ra, 2da y 7ma fila\nroedores_mod &lt;- roedores[c(-1,-2,-7),]\n\n# Ahora intenta esto\nroedores_mod &lt;- roedores[,-1]\n# ¿Qué pasó luego de ejecutar este código?\n# Observa la posición de la coma\n\n\n\n\n\n\n\nEjercicio\n\n\n\nAñade dos nuevas columnas a la matriz roedores y posteriormente elimina los datos desde la 2da hasta la 4ta fila.\n\n\nTambién puedes usar distintas funciones para analizar cualquier matriz.\n\nhead(roedores)\nnrow(roedores)\nclass(roedores)\n\nPuedes leer mas sobre estas funciones en la sección de ayuda.\n\n\n1.5.3 Data frames\nUn data frame es un set de datos que puede estar conformado tanto por valores numéricos o también por caracteres. Trabajar con este tipo de objetos es una aproximación más realista debido al tipo de .\nContinuemos con nuestro ejemplo de los roedores, supongamos que quieres agregar una columna que contenga un vector de caracteres y se le asigne el nombre de especie a cada roedor. Para este propósito organizaremos los datos de pesos de los roedores en filas.\n\n# Añade varias veces los objetos creados anteriormente\nroedores &lt;- cbind(roedor1, roedor2, roedor1, roedor2)\nclass(roedores)\n## [1] \"matrix\" \"array\"\n\n#Crea un vector de caracteres\nlocalidad &lt;- c(\"Quito\", \"Guayaquil\")\n\nEl objeto roedores es aún una matriz, ¿cómo podrías añadir las localidades para convertirlo en un data frame?\n\n# Utiliza la función data.frame\nroedores &lt;- data.frame(roedores, localidad)\n\n# Analiza el data frame\nclass(roedores)\nsummary(roedores)\nstr(roedores)\n\nLa función summary y str nos brindan información relevantes que será necesaria en clases posteriores. ¿Qué pasa si quieres saber algo más específico como cuántos valores por debajo de 25 existen en el data frame?\n\nroedores &lt;= 25\n##      roedor1 roedor2 roedor1.1 roedor2.1 localidad\n## [1,]    TRUE   FALSE      TRUE     FALSE     FALSE\n## [2,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [3,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [4,]    TRUE    TRUE      TRUE      TRUE     FALSE\n## [5,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [6,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [7,]    TRUE   FALSE      TRUE     FALSE     FALSE\n## [8,]   FALSE    TRUE     FALSE      TRUE     FALSE\n\nEjecutar este código nos devuelve valores lógicos o también llamados booleanos como resultado. Cada TRUE o FALSE puede ser contado individualmente, pero ¿cómo lograrías contarlos automáticamente?\n\nsum(roedores&lt;= 25)\n#Ahora utiliza la función which(), ¿cuál es la diferencia?\n\nTambién puedes elegir columnas individuales y realizar el mismo procedimiento. El signo $ señala cual es la columna de la cual quieres tomar los datos.\n\nroedores$roedor1 &gt; 25\n\nLa manipulación de esta clase de objetos será ampliada y tratada con más detenimiento en la siguiente clase.\n\n\n1.5.4 Listas\nxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#estructura-de-datos",
    "href": "intro.html#estructura-de-datos",
    "title": "1  Introducción a R",
    "section": "1.5 Estructura de datos",
    "text": "1.5 Estructura de datos\nR contiene una jerarquía de elementos y provee varios tipos de estructuras de datos especializadas a las que se les conoce como objetos. Para los propósitos de este curso mencionaremos a los vectores y matrices pero nos enfocaremos en los data frames. Sin embargo, es importante saber que existen otros tipos de estructuras de datos como las listas, que utilizaremos ampliamente en el nivel avanzado de este curso.\n\n1.5.1 Vectores\nUn vector es una secuencia de datos del mismo tipo ya sean numéricos o de carácter. Así, para construir vectores numéricos, deberemos primeramente nombrar a nuestro objeto y asignarle valores mediante &lt;-. Supongamos que quieres almacenar los resultados de las operaciones anteriores en un objeto “x” e “y”.\n\nx &lt;- log(5)\n\ny &lt;- log(5)/log2(5*3)\n\nObserva que en el panel Environment ahora hay dos objetos que corresponden a los vectores numéricos que creaste con los resultados de cada operación. De esta manera, ahora será más fácil manipular estos datos.\n\n# Ejecuta lo siguiente\nx*y\n\n# Almacena el resultado de ambos objetos en un vector nuevo\nz &lt;- x*y\n\n# Puedes imprimir el resultado en la consola\nz\n\nAhora crea una secuencia de números dentro de un vector. Una forma rápida de crear este tipo de vectores es mediante la función seq.\n\n# Puedes crear números sucesivos del 1 - 10\na &lt;- c(1:10)\n\n# O una secuencia hasta el 15 con un intervalo de 3\nb &lt;- seq(1, 15, 3)\n\nLa función seq crea secuencias en este caso del número 1 hasta el 15, con un intervalo de 3. Pero, ¿cómo podrías saber qué significa cada argumento dentro de una función si no la conoces?\nExisten dos maneras de indagar sobre una función cualquiera y obtener ayuda sobre la misma:\n\n?seq\nhelp(seq)\n\nLa sección de ayuda contiene todo lo que debes saber sobre cualquier función. Al final de cada manual de instrucciones de la función podrás ver además ejemplos que te ayudarán a entenderla y aplicarla según tus necesidades.\nAhora bien, puedes aplicar esto a un ejemplo más cotidiano. Imagina que posees datos de distintos pesos de varios individuos de una especie de roedor que has capturado y quieres realizar algunas operaciones con ellos. Almacena estos pesos dentro de un vector utilizando la función concatenar c().\n\npesos &lt;- c(25, 27, 30, 20, 26, 27.5, 23, 30.8)\n\nAhora que tienes estos datos almacenados en un vector, puedes realizar operaciones con ellos.\n\n# Número de observaciones\nlength(pesos)\n\n# Valores minimos y maximos\nmin(pesos)\nmax(pesos)\n\n# Promedio\nmean(pesos)\n\nPara hacer este ejemplo aún más real, imagina que las medidas tomadas eran erróneas o ya no sirven para su estudio. Puedes entonces modificar el vector de la siguiente manera:\n\n# Elimina el cuarto valor en nuestro vector\npesos_mod &lt;- pesos[-4]\n\n# Remueve desde el primer hasta el quinto valor\npesos_mod &lt;- pesos[-1:-5]\n\n# Agrega más valores al vector\npesos_mod &lt;- c(pesos, 21, 28.3, 31, 26.5)\n\nCuando modificas un vector es usualmente aconsejable crear uno nuevo y almacenar la nueva información en éste. El código no siempre se verá tan sencillo como en el ejemplo anterior y es mejor trabajar de una manera segura al manipular metadatos.\nEs muy útil saber que si deseas eliminar cualquier objeto, lo puedes hacer en cualquier momento mediante la función remove() o rm().\n\n\n1.5.2 Matrices\nUna matriz no es más que un conjunto de datos del mismo tipo organizado de forma bidimensional, es decir, en filas y columnas. Crear y modificar matrices tiene también un proceso parecido al de los vectores.\n\nmatriz &lt;- matrix(1:14, ncol=7)\nmatriz\n\n\n\n\n\n\n\nEjercicio\n\n\n\nOrganiza diferentes matrices con diferentes números de columnas y filas, usa help(matrix) para saber como hacerlo. ¿Qué sucede si organizas la matriz mediante matrix(2:14, ncol=3)?:\n\n\nEste método solo crea matrices con datos secuenciales, entonces ¿cómo podrías organizar distintos pesos de roedores de forma bidimensional? Siguiendo con el ejemplo de los roedores, supongamos que tienes dos especies de roedores.\n\nroedor1 &lt;- c(25, 27, 30, 20, 26, 27.5, 23, 30.8)\nroedor2 &lt;- c(26, 26.5, 30, 20, 31, 27.5, 28, 20.8)\n\n# Lee sobre cbind usando help()\nroedores &lt;- cbind(roedor1, roedor2)\n\n# Ahora utiliza rbind() para unir ambos vectores. ¿Cuál es la diferencia?\n\nAl igual que los vectores, las matrices también pueden ser modificadas. Sin embargo, al haber añadido una dimensión más, la forma de editarlas cambia dependiendo de si quieres modificar una fila o una columna.\n\n# Elimina la cuarta fila\nroedores_mod &lt;- roedores[-4,]\n\n# Elimina la 1ra, 2da y 7ma fila\nroedores_mod &lt;- roedores[c(-1,-2,-7),]\n\n# Ahora intenta esto\nroedores_mod &lt;- roedores[,-1]\n# ¿Qué pasó luego de ejecutar este código?\n# Observa la posición de la coma\n\n\n\n\n\n\n\nEjercicio\n\n\n\nAñade dos nuevas columnas a la matriz roedores y posteriormente elimina los datos desde la 2da hasta la 4ta fila.\n\n\nTambién puedes usar distintas funciones para analizar cualquier matriz. Puedes leer mas sobre estas funciones en la sección de ayuda.\n\nhead(roedores)\nnrow(roedores)\nclass(roedores)\n\n\n\n1.5.3 Data frames\nUn data frame es un set de datos que puede estar conformado por valores numéricos y caracteres. Trabajar con este tipo de objetos es una aproximación más realista a lo que ecncontrarás cotidianamente como verás a lo largo de este curso.\nContinuando con el ejemplo de los roedores, agrega una columna que contenga un vector de caracteres y asigna el nombre de especie a cada roedor. Para este propósito puedes organizar los datos de pesos de los roedores en filas.\n\n# Añade varias veces los objetos creados anteriormente\nroedores &lt;- cbind(roedor1, roedor2, roedor1, roedor2)\nclass(roedores)\n## [1] \"matrix\" \"array\"\n\nEl objeto roedores es aún una matriz, ¿cómo podrías añadir las localidades para convertirlo en un data frame?\n\n#Crea un vector de caracteres\nlocalidad &lt;- c(\"Quito\", \"Guayaquil\")\n\n# Utiliza la función data.frame\nroedores &lt;- data.frame(roedores, localidad)\n\n# Analiza el data frame\nclass(roedores)\nsummary(roedores)\nstr(roedores)\n\nLa función summary y str brindan información relevante que te permite tener una vista rápida para entender la organización de tus datos. Sin embargo, ¿cómo podrías saber algo más específico como cuántos valores por debajo de 25 existen en el data frame?\n\nroedores &lt;= 25\n##      roedor1 roedor2 roedor1.1 roedor2.1 localidad\n## [1,]    TRUE   FALSE      TRUE     FALSE     FALSE\n## [2,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [3,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [4,]    TRUE    TRUE      TRUE      TRUE     FALSE\n## [5,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [6,]   FALSE   FALSE     FALSE     FALSE     FALSE\n## [7,]    TRUE   FALSE      TRUE     FALSE     FALSE\n## [8,]   FALSE    TRUE     FALSE      TRUE     FALSE\n\nEjecutar este código nos devuelve valores lógicos o también llamados booleanos como resultado. Cada TRUE o FALSE puede ser contado individualmente, pero ¿cómo lograrías contarlos automáticamente?\n\nsum(roedores&lt;= 25)\n#Ahora utiliza la función which(), ¿cuál es la diferencia?\n\nTambién puedes elegir columnas individuales y realizar el mismo procedimiento. El signo $ señala cual es la columna de la cual quieres tomar los datos.\n\nroedores$roedor1 &gt; 25\n\nLa manipulación de esta clase de objetos será ampliada y tratada con más detenimiento en la siguiente clase.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "index.html#código-de-conducta",
    "href": "index.html#código-de-conducta",
    "title": "Introducción a la Telemetría de Grandes Mamíferos",
    "section": "Código de conducta",
    "text": "Código de conducta\nQueremos asegurarnos que tu expreiencia en el curso sea lo más agradable y fluida posible, y que puedas aprovechar al máximo el tiempo con nosotros.\nPara poder llevar las actividades dentro del horario establecido y con normalidad, te pedimos:\n\nActualización de Zoom: Asegúrate de tener la última versión de Zoom instalada. Esto te evitará problemas al ingresar a la sala.\nNombre y país de origen: Cuando ingreses a la sesión, agrega tu nombre y apellido seguido de un guion y tu país de origen. Por ejemplo: Francisco Castellanos - Ecuador.\nCámara apagada, micrófono en silencio: Para que nuestra conexión sea lo más estable posible, te sugerimos mantener tu cámara apagada y micrófono en silencio la mayor parte del tiempo. Esto nos ayudará a evitar distracciones y garantizar una experiencia de calidad para todos.\n¡Participa!: El micrófono debe permanecer apagado para evitar interrupciones. Sin embargo, ya que buscamos que nuestras clases sean interactivas, el micrófono puede ser encendido en cualquier momento para realizar preguntas o comentarios que aporten con la discusión en la clase.\n\nPor favor, recuerda que queremos mantener un ambiente respetuoso y amigable para todos. Cualquier comportamiento inapropiado o que perturbe la armonía del grupo podría resultar en la expulsión de la sala. Queremos que todos se sientan cómodos y seguros aquí, así que te pedimos que respetes estas normas para que podamos disfrutar de nuestro tiempo juntos al máximo.",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "intro.html#tidyverse",
    "href": "intro.html#tidyverse",
    "title": "1  Introducción a R",
    "section": "2.1 tidyverse",
    "text": "2.1 tidyverse\ntidyverse es una colección de paquetes que contiene a dplyr y ggplot2. Estos han sido creados para facilitar la manipulación y visualización de datos mediante gráficos estéticos con varias opciones para modificarlos y presentarlos. Puedes ver algunos ejemplos en la galería oficial de ggplot2, y varios ejemplos sobre las extensiones que han sido escritas para ampliar aún más el funcionamiento de este paquete.\nUna vez hayas activado dplyr, ya puedes utilizarlo para buscar datos específicos en el data frame “roedores” utilizando una sintaxis diferente a la que aprendiste recientemente.\n\nlibrary(dplyr)\n\n# Filtra por localidad\nfilter(roedores, localidad == \"Quito\")\n\n# Almacena los resultados en un objeto nuevo llamado capital\ncapital &lt;- filter(roedores, localidad == \"Quito\")\ncapital &lt;- select(capital, roedor2)\n\n\n\n\n\n\n\nTarea\n\n\n\nUtiliza todo lo aprendido en esta clase y el set de datos roedores y responde: ¿cuántos individuos de Guayaquil tienen pesos menores o iguales a 26.5?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "intro.html#ggplot2",
    "href": "intro.html#ggplot2",
    "title": "1  Introducción a R",
    "section": "2.2 ggplot2",
    "text": "2.2 ggplot2\nAhora que cuentas con un data frame, puedes visualizar los datos de una manera estética y comprensible. Por ahora, aprenderás a utilizar algunasfunciones de este paquete, sin un fin específico, y más adelante te concentrarás en ponerlo en uso con un objetivo de comunicación científica. Activa el paquete ggplot2 y ejecuta:\n\nggplot(data = roedores) +\n  geom_point(aes(x = roedor1, y = roedor2),\n             size = 5)\n\n\n\n\n\n\n\n\nAhora colorea cada punto en base a la localidad de muestreo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\nUtiliza el manual de ayuda de geom_point() o haz una búsqueda en internet para descifrar como elaboré este gráfico.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a R</span>"
    ]
  },
  {
    "objectID": "analisis_data.html",
    "href": "analisis_data.html",
    "title": "2  Análisis de datos",
    "section": "",
    "text": "2.1 Importando datos en R\nAntes de ingresar nuestros datos, es muy importante indicar a R cuál será nuestro directorio de trabajo o también llamado Working Directory. Es decir, debemos establecer la carpeta dentro de la cual se encuentran los archivos a utilizar, y donde se exportarán los que generes durante tu trabajo.\nR toma automáticamente un directorio en el cual trabajar y puedes saber cual es con la función getwd().\nExisten algunas formas de establecer el lugar de trabajo. La primera es de manera manual:\nsetwd(\"~/Curso_R/Estadistica_basica\")\nNota que el símbolo ~ se encuentra al inicio del directorio escrito. Este símbolo reemplaza al resultado obtenido de la función getwd.\nLa segunda manera de establecer el directorio es presionando las teclas Ctrl+Shift+H. Inmediatamente se abrirá una ventana en la que podrás seleccionar tu directorio manualmente.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#archivos-csv",
    "href": "analisis_data.html#archivos-csv",
    "title": "2  Análisis de datos",
    "section": "2.2 Archivos csv",
    "text": "2.2 Archivos csv\nAntes de importar nuestros datos, debemos tener claro cuál es la extensión de estos ya que diferentes formatos implican diferentes funciones para importarlos en R.\nTanto los archivos txt y xlsxl resultan un poco más complicados de leer e incluso necesitan la instalación de otros paquetes como readxl. Por otro lado, los archivos csv (comma separated values) con los que trabajarás en esta clase, se pueden importar de esta manera:\n\ndata &lt;- read.csv(\"osos_hema.csv\")\n\n\n\n\n\n\n\nImportant\n\n\n\nAsegúrate que el archivo osos_hema.csv se encuentra en el directorio que indicaste previamente.\n\n\nUna vez que hayas immportado el archivo, lo puedes ver como data frame en el panel Environment. Puedes hacer clic sobre el objeto e inspeccionarlo brevemente.\nRepasa brevemente las funciones que aprendiste en Chapter 1 para obtener datos más específicos sobre el objeto data.\n\nhead(data)\nsummary(data)\nstr(data) #Tipo de variable de nuestro objeto\n\nObservamos que tenemos una cantidad importante de datos faltantes (NA’s). Veamos si estos NA’s son un problema para calcular la media y mediana de la columna colesterol.\n\nmean(data$colesterol)\nmedian(data$colesterol)\n\nLos resultados nos indican que no podemos calcular estas medidas de tendencia sin haber limpiado primeramente el data frame. Para poder hacerlo, podríamos limpiar todo nuestro set de datos, pero se perdería mucha información de esta manera. Por ende, es aconsejable elegir las columnas que nos interesen y realizar la limpieza de NA’s únicamente en éstas.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#importando-datos-en-r",
    "href": "analisis_data.html#importando-datos-en-r",
    "title": "2  Análisis de datos",
    "section": "",
    "text": "2.1.1 Archivos csv\nPuedes descargar el achivo utilizado en este tutorial desde este link . Antes de importar este u otro archivo debes tener claro cuál es el tipo de extensión, ya que diferentes formatos implican diferentes funciones para importarlos.\nTanto los archivos txt y xlsxl resultan un poco más complicados de leer e incluso necesitan la instalación de otros paquetes como readxl. Por otro lado, los archivos csv (comma separated values) con los que trabajarás en esta clase, se pueden importar de esta manera:\n\ndata &lt;- read.csv(\"osos_hema.csv\")\n\n\n\n\n\n\n\nImportant\n\n\n\nAsegúrate que el archivo osos_hema.csv se encuentra en el directorio que indicaste previamente.\n\n\nUna vez que hayas importado el archivo, lo puedes ver como data frame en el panel Environment. Puedes hacer clic sobre el objeto e inspeccionarlo brevemente.\nRepasa las funciones que aprendiste en Chapter 1 para obtener datos más específicos sobre el objeto data.\n\nhead(data)\nsummary(data)\nstr(data)\n\nObserva que hay una gran cantidad de datos faltantes, NA’s. ¿Son estos datos faltantes un problema para calcular la media y mediana de la columna colesterol?\n\nmean(data$colesterol)\n## [1] NA\nmedian(data$colesterol)\n## [1] NA\n\nLos resultados muestran que no es posible calcular estas medidas de tendencia sin haber limpiado el data frame. Para poder hacerlo, es aconsejable elegir las columnas de interés y realizar la limpieza de NA’s únicamente en éstas.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html",
    "href": "datos_telemetricos.html",
    "title": "3  Datos de telemetría satelital",
    "section": "",
    "text": "3.1 Importación, limpieza y visualización de datos telemétricos\nEs de suma importancia que estos pasos sean realizados de manera correcta, ya que cualquier error en la importación y limpieza de los datos nos puede traer grandes errores.\nA manera de ejercicio, he tomado material del curso Landscape and Analysis Modeling de The University of Tulsa, al que pueden acceder gratuitamente para profundizar más en los temas que trataremos en estas clases. Además, modifiqué el formato del archivo original MigratoryZebra.csv, por un motivo que será obvio a continuación.\nEs siempre aconsejable tener una mirada general de los datos antes de leerlos como objetos en R, ya que se debe utilizar la función adecuada para su lectura. Descarga y abre el archivo que usarás en este módulo zebras.csv, en un archivo de texto y observa algunas características importantes del archivo como los separadores de columnas y los indicadores de decimales.\nPuedes ver que las columnas están separadas por ;, y los decimales mediante ,.\n# Intenta importar el archivo y mira las características de estos objetos mediante summary() y str()\n\ndata1 &lt;- read.csv(\"zebras.csv\")\ndata2 &lt;- read.csv2(\"zebras.csv\")\ndata3 &lt;- read.table(\"zebras.csv\", header = TRUE, na.strings = \"NA\",  sep=\";\")\nAhora activa el paquete readr (también parte de tidyverse) e intenta importar los datos mediante la función read_csv2.\ndata &lt;- read_csv2(\"zebras.csv\")\nsummary(data)\nstr(data)\nYa que tienes el archivo debidamente importado, extrae algunas columnas de interés y asigna un nombre más intuitivo, fácil de escribir y recordar. Esta es una preferencia personal, así que puedes omitir esta parte según tu preferencia.\nzebras &lt;- data[, c(\"event-id\", \"individual-local-identifier\",\n                \"location-long\", \"location-lat\", \"study-local-timestamp\")]\n\nzebras &lt;- zebras %&gt;%\n              rename(id = \"event-id\", identifier = \"individual-local-identifier\",\n              long = \"location-long\",\n              lat = \"location-lat\",\n              timestamp = \"study-local-timestamp\")\n\n# Inspecciona las primeras filas y los nombres de las columnas\nhead(zebras)\n## # A tibble: 6 × 5\n##          id identifier  long   lat timestamp              \n##       &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;                  \n## 1 210260446 Z3864       23.5 -19.4 2007-10-25 02:02:11,000\n## 2 210260447 Z3864       23.5 -19.4 2007-10-25 03:01:49,000\n## 3 210260448 Z3864       23.5 -19.4 2007-10-25 04:01:38,000\n## 4 210260449 Z3864       23.5 -19.4 2007-10-25 05:02:18,000\n## 5 210260450 Z3864       23.5 -19.4 2007-10-25 06:01:35,000\n## 6 210260451 Z3864       23.5 -19.4 2007-10-25 07:02:16,000\nAhora puedes observar la distribución de estas zebras de una manera sencilla mediante funciones base.\nLos individuos muestreados se encuentran en una extensión de terreno enorme, por lo que es preferible para los fines de esta primera lección, que analices animales que comparten un mismo espacio geográfico. Para esto, puedes hacer un subset del data frame original, y además puedes practicar tus habilidades en manejar dyplyr.\ndos_zebras &lt;- zebras %&gt;%\n          filter(identifier == \"Z3864\" | identifier == \"Z6405\") %&gt;%\n          dplyr::select(identifier, long, lat, timestamp)\nRealiza nuevamente un gráfico asignando colores a cada individuo.\nComo has aprendido en lecciones anteriores, no es conveniente embarcarse en algúm tipo de análisis sin antes realizar una limpieza de tus datos. Ahora puedes proceder a remover los NA’s de las columnas señaladas por summary.\n# Investiga si el set de datos posee NAs\nsummary(dos_zebras)\n##   identifier             long            lat          timestamp        \n##  Length:8915        Min.   :23.52   Min.   :-20.81   Length:8915       \n##  Class :character   1st Qu.:23.61   1st Qu.:-20.59   Class :character  \n##  Mode  :character   Median :24.88   Median :-20.44   Mode  :character  \n##                     Mean   :24.47   Mean   :-20.15                     \n##                     3rd Qu.:25.00   3rd Qu.:-19.44                     \n##                     Max.   :25.26   Max.   :-19.39                     \n##                     NA's   :1       NA's   :1\nwhich(is.na(dos_zebras$lat))\n## [1] 1802\nwhich(is.na(dos_zebras$long))\n## [1] 1802\n!Haz limpiado los datos con éxito! Ahora crea un objeto que será transformado y proyectado posteriormente.\nzebras.proj &lt;- dos_zebras",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "areas_vida_1.html",
    "href": "areas_vida_1.html",
    "title": "4  Áreas de vida Parte I",
    "section": "",
    "text": "4.1 adehabitatHR\nEl paquete adeHabitatHR es uno de cuatro paquetes que hace unos años formaban parte del paquete ya deprecado adehabitat, y se especializa en el análisis de áreas de vida. Este paquete, sin embargo, se enfrenta a un riesgo a futuro ya que otros paquetes utilizados dentro de la disciplina del análisis espacial, dependían en gran medida de los paquetes raster, rgdal, rgeos, y sp, que fueron reemplazados en el 2023 por sf y terra. sp es el único que se adaptó a esta transición y adoptó funciones del paquete sf Sin embargo, adehabitatHR no se adaptó a esta transformación y depende de la instalación de estos paquetes que ya no reciben mantenimiento.\nA pesar de esto, aprender sobre adeHabitatHR es aún necesario ya que no existe, a la fecha, un paquete que incorpore todas las utilidades que éste lo hace.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Áreas de vida Parte I</span>"
    ]
  },
  {
    "objectID": "areas_vida_2.html",
    "href": "areas_vida_2.html",
    "title": "5  Áreas de vida Parte II",
    "section": "",
    "text": "Estamos trabajando en este tutorial",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Áreas de vida Parte II</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#manipulación-de-data-frames",
    "href": "analisis_data.html#manipulación-de-data-frames",
    "title": "2  Análisis de datos",
    "section": "2.2 Manipulación de data frames",
    "text": "2.2 Manipulación de data frames\nAhora aprenderás a manipular los datos que serán analizados en la sección 2.3, e investigarás si existe alguna diferencia entre la media de colesterol de machos y hembras, y si la hubiera, testearás si esta disimilitud es estadísticamente significativa realizando la prueba de hipótesis estadística T de Student.\nPor último, investigarás si existe correlación entre los niveles de colesterol y triglicéridos en ambos sexos. Para esto necesitas algunos paquetes.\n\nlibrary(tidyverse)\nlibrary(rafalib)\n\nPara deshacerte de los NA's puedes extraer las columnas de interés de una manera parecida a la que has aprendido anteriormente.\n\nlipidos &lt;- data[ ,c(\"colesterol\", \"trigliceridos\", \"sexo\")]\nlipidos &lt;- na.omit(lipidos)\n\n# También puedes buscar las filas que poseen NA’s\nwhich(is.na(data$colesterol))\n\n\n\n\n\n\n\nTarea\n\n\n\n¿Cómo podrías deshacerte de los NA's utilizando which(is.na())?\n\n\n\n2.2.1 pipes\nAhora usarás una de las funciones más populares del paquete magrittr (parte de tidyverse), llamado pipe y escrito como %&gt;%. Este operador se utiliza mucho en lenguaje de programación ya que simplifica la unión de funciones. Sin embargo, desde la versión de R 4.1.0, se introdujo el operador nativo |&gt;. El uso de ambos depende del contexto en el cual son implementados como se discute en este artículo, y hay un gran resumen del uso de cada uno aquí.\nSea cual sea tu elección, ambos pipes se traducen a lenguaje común como “después”, y se utilizan para pasar el output de una primer función hacia una segunda, tercera, etc.\nPuedes aprovechar esta función para simplificar la escritura del código para extraer ciertas columnas de data.\n\n# Extrae las columnas de lipidos y sexo\nlipidos &lt;- data %&gt;%\n            select(colesterol, trigliceridos, sexo) %&gt;%\n            na.omit()\n\n# Extrae las columnas de compuestos nitrogenados y sexo\nnitrogenados &lt;- data %&gt;%\n                select(proteina, bun, sexo) %&gt;%\n                na.omit()\n\nAhora el código es más fácil de interpretar y este se lee como: “toma el objeto data; después selecciona las columnas colesterol, triglicéridos y sexo; después omite los NA’s”. Esto se lee de igual manera para el objeto nitrogenados.\n\n\n2.2.2 Manipulación semi-avanzada\nPuedes hacer mucho más con este set de datos hipotético que puedes aplicar en tu propia investigación.\n\n# Agrega una columna con la relación proteina/bun\ndata %&gt;%\n  select(proteina, bun, sexo) %&gt;%\n  na.omit() %&gt;%\n  mutate(proteina_bun_ratio = proteina / bun) %&gt;%\n  head()\n##     proteina       bun   sexo proteina_bun_ratio\n## 1 12.3057808 10.981548 hembra         1.12058703\n## 2 14.5265548 16.572126 hembra         0.87656556\n## 3  2.6605606  3.772625 hembra         0.70522797\n## 4 12.8490715  8.128610  macho         1.58072177\n## 5  0.9260416 12.113160  macho         0.07644922\n## 6  3.1239402 17.496444 hembra         0.17854715\n\n# Agrega categorías por rangos\ndata %&gt;%\n  select(proteina, bun, sexo) %&gt;%\n  na.omit() %&gt;%\n  mutate(categoria_bun = case_when(\n    bun &lt; 15 ~ \"Bajo\",\n    bun &gt;= 15 & bun &lt;= 20 ~ \"Normal\",\n    bun &gt; 20 ~ \"Alto\")) %&gt;%\n    head(n = 10)\n##      proteina       bun   sexo categoria_bun\n## 1  12.3057808 10.981548 hembra          Bajo\n## 2  14.5265548 16.572126 hembra        Normal\n## 3   2.6605606  3.772625 hembra          Bajo\n## 4  12.8490715  8.128610  macho          Bajo\n## 5   0.9260416 12.113160  macho          Bajo\n## 6   3.1239402 17.496444 hembra        Normal\n## 9   7.3849111  8.768299 hembra          Bajo\n## 10  4.6996813 11.005729  macho          Bajo\n## 14 21.7550518 18.432460 hembra        Normal\n## 15 15.9212473 18.828829  macho        Normal\n\n\n\n\n\n\n\nEjercicio\n\n\n\n¿Cómo harías para seleccionar y guardar únicamente los valores normales en nuevo data frame?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#subsec-est-basica",
    "href": "analisis_data.html#subsec-est-basica",
    "title": "2  Análisis de datos",
    "section": "2.3 Estadística básica en R",
    "text": "2.3 Estadística básica en R\n\n\n\nSeguimos trabajando en este tutorial",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#sec-est-basica",
    "href": "analisis_data.html#sec-est-basica",
    "title": "2  Análisis de datos",
    "section": "2.3 Estadística básica en R",
    "text": "2.3 Estadística básica en R\nPuedes realizar una exploración rápida de tus datos antes de iniciar análisis específicos. Observemos en un scatterplot como se distribuyen los datos.\n\nplot(data)\n\n\n\n\n\n\n\n\n\n2.3.1 Correlación\nParece ser que hay algún tipo de relación entre las variables de colesterol y triglicéridos. Podemos utilizar la función cor para determinar si de hecho existe alguna correlación.\n\ncor(lipidos$colesterol, lipidos$trigliceridos)\n## [1] 0.4223668\n\nEste resultado, sin embargo, no es muy claro pero recuerda que no estamos separando estos datos basados en otra variable como edad o sexo, que podrían tener una influencia en este resultado. Además, por default cor utiliza el método de Pearson. ¿Cambiaría este resultado en base al uso de otro método?\n\n\n\n\n\n\nEjercicio\n\n\n\nCalcula la correlación de estas variables mediante el método de Spearman.\n\n\nAhora apliquemos más funciones de dplyr junto con los pipes para calcular la correlación en base al sexo.\n\nlipidos %&gt;%\n    group_by(sexo) %&gt;%\n    summarise(cor = cor(colesterol, trigliceridos))\n## # A tibble: 2 × 2\n##   sexo     cor\n##   &lt;chr&gt;  &lt;dbl&gt;\n## 1 hembra 0.340\n## 2 macho  0.473\n\nTambién puedes utilizar ggplot2 para graficar esta posible correlación.\n\nlipidos %&gt;%\n    ggplot(aes( x = colesterol, y = trigliceridos, color = sexo)) +\n    geom_point(alpha = 0.5) +\n    geom_smooth(method = \"lm\", se = FALSE) +\n    labs( x = \"colesterol (mg/dl)\", y = \"triglicéridos (mg/dl)\") +\n    theme_bw()\n\n\n\n\n\n\n\n\n\n\n2.3.2 Diferencias de medias\nAhora utiliza el objeto nitrogenados e inspecciona en detalle alguna diferencia entre machos y hembras.\n\nnitrogenados %&gt;%\n    select(bun, sexo) %&gt;%\n    group_by(sexo) %&gt;%\n    summarise(media = mean(bun),\n                mediana = median(bun),\n                desv_est = sd(bun))\n\nEstas posibles diferencias también pueden ser observadas mediante un gráfico de caja y bigotes.\n\nboxplot(nitrogenados$bun ~ nitrogenados$sexo)\n\n\n\n\n\n\n\nboxplot(nitrogenados$proteina ~ nitrogenados$sexo)\n\n\n\n\n\n\n\n\nLa diferencia de medidas de tendencia entre sexos no es clara. Sin embargo, ¿cómo podemos saber que esta diferencia es o no estadísticamente significativa?\nAunque a fines de este ejemplo, utilizaremos el test de Student para calcular el valor p, es necesario aclarar que no profundizaremos en detalles matemáticos o discutiremos sobre que tipos de test podrían contestar esta pregunta de mejor manera. Si deseas tener más conocimiento sobre temas estadísticos, dirígete a la sección de Fuentes de este documento y descarga los libros y documentos que sean de tu interés.\nPrimero, debemos observar si nuestros datos siguen una distribución normal. Para esto utilizaremos funciones base de R y además la función mypar() del paquete rafalib que instalamos previamente.\n\nmypar(1,2)\n# Grafica un histograma\nhist(nitrogenados$bun, main = \"Distribución de valores de Urea en sangre\")\n\n# y además\nqqnorm(nitrogenados$bun)\nqqline(nitrogenados$bun)\n\n\n\n\n\n\n\n\nSi deseas saber más sobre el significado de los Q-Q plots, ingresa aquí.\nSi quieres aumentar la confianza sobre la normalidad de tu set de datos, puedes utilizar la función shapiro.test.\n\nshapiro.test(nitrogenados$bun)\n## \n##  Shapiro-Wilk normality test\n## \n## data:  nitrogenados$bun\n## W = 0.97721, p-value = 5.523e-10",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#sec:est-basica",
    "href": "analisis_data.html#sec:est-basica",
    "title": "2  Análisis de datos",
    "section": "2.3 Estadística básica en R",
    "text": "2.3 Estadística básica en R\n\n\n\nSeguimos trabajando en este tutorial",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#personalizando-gráficos-con-ggplot2",
    "href": "analisis_data.html#personalizando-gráficos-con-ggplot2",
    "title": "2  Análisis de datos",
    "section": "2.6 Personalizando gráficos con ggplot2",
    "text": "2.6 Personalizando gráficos con ggplot2\nExisten tres sistemas de plotting en R, base plotting, el paquete lattice y ggplot2. Por ahora nos concentraremos en indagar en algunas de las tantas opciones de personalización que nos ofrece ggplot2 y de otros paquetes que interactúan con éste.\n\n2.6.1 Plotly\nImaginemos que una vez concluidos nuestros análisis, estamos disconformes con ellos y creemos que puede deberse a un error en los datos. ¿Como podríamos identificar entre tantos valores a aquel que genera un error en el cálculo de estadísticos? Para generar el gráfico que nos puede ayudar a responder esta pregunta, necesitaremos descargar primeramente el paquete plotly.\n\nlibrary(plotly)\n\n# Crea un objeto que contenga un ggplot de nuestro dataset lipidos.\nlipidos_valores &lt;- lipidos %&gt;%\n                    ggplot(aes(x = colesterol, y = trigliceridos, colour = sexo)) +\n                    geom_point() +\n                    # Cambia el temadel plot\n                    theme_light() +\n                    # Cambia los nombres de los ejes\n                    labs( y = \"Triglicéridos\", x = \"Colesterol\")\n\n# !Observa el gráfico interactivo!\nggplotly(lipidos_valores)\n\n\n\n\n\nEste gráfico interactivo aparecerá en la pestaña Viewer y te permitirá ubicarte sobre cualquier punto del scatterplot y observar su valor en el eje de coordenadas. Esto será muy útil más adelante para deshacernos de outliers en los análisis espaciales.\n\n\n2.6.2 Paquetes que interactúan con ggplot2\n\n2.6.2.1 ggExtra\nEste es un paquete que mejora la visualización de gráficas adjuntando histogramas, boxplots y plots de densidad hacia los márgenes de una gráfica realizada en ggplot2.\n\nlibrary(ggExtra)\n\n# ¿Por qué crees que almacenamos el siguiente gráfico como un objeto?\ng &lt;- ggplot(lipidos, aes(colesterol, trigliceridos, colour=sexo)) +\n        geom_point() +\n        # Agrega regresiones lineales\n        geom_smooth(method = \"lm\", se = F) +\n        # Agrega un título al plot\n        labs(title = \"Correlación y Distribución \\nde lípidos\") +\n        # Cambia el tema del plot\n        theme_bw () +\n        # La posición de la leyenda y el tamaño de la letra\n        theme(legend.position = \"bottom\",\n                text = element_text(size = 15))\n\n# Crea un gráfico con ggExtra\nggMarginal(g, type = \"histogram\", fill = \"transparent\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\nLee el apartado de ayuda de ggMarginal y grafica un diagrama de caja y bigotes en lugar de un histograma.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#fuentes",
    "href": "analisis_data.html#fuentes",
    "title": "2  Análisis de datos",
    "section": "2.7 Fuentes",
    "text": "2.7 Fuentes\nEste capítulo fue tomado y adaptado de diversas fuentes, siendo R for Data Science, el curso gratis de edX Statistics and R, y Linear Algebra for Data Science with examples in R las más grandes influencias de este trabajo.\nTanto el análisis estadístico como la creación de gráficos utilizando ggplot2 son temas muy amplios para los cuales existen una amplia gama de recursos en internet. En cuanto a la parte estadística, he hecho una recopilación muy breve de libros que abordan estos temas, así como también sobre la investigación reproducible, su importancia, y como llevarla a cabo en R. Para acceder a estos recursos haz clic aquí.\nFinalmente, puedes profundizar más en el uso de ggplot2 ingresando a: Data Visualization with R , Top 50 ggplot2 Visualizations y Data visualization with ggplot2.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#t-test",
    "href": "analisis_data.html#t-test",
    "title": "2  Análisis de datos",
    "section": "2.4 t-Test",
    "text": "2.4 t-Test\nAhora que sabemos que los niveles de colesterol siguen una distribución normal, estamos listos para calcular el valor p. Primero necesitamos separar en dos objetos a nuestro objeto lipidos. ¿Por qué?\n\n# Crea un objeto con los machos\nbun_m &lt;- nitrogenados%&gt;%\n            filter(sexo == \"macho\") %&gt;%\n                select(bun) %&gt;% unlist()\n\n# Ahora uno con las hembras\nbun_h &lt;- nitrogenados %&gt;%\n            filter(sexo == \"hembra\") %&gt;%\n                select(bun) %&gt;% unlist()\n\n\n\n\n\n\n\nEjercicio\n\n\n\n¿Cómo fueron almacenados los objetos col_m y col_h?. Lee sobre unlist en la sección de Ayuda.\n\n\nAhora puedes realizar la prueba T de Studentcon la seguridad de que tus datos siguen una distribución normal.\n\nt.test(bun_h, bun_m, var.equal = T)\n\n#Si solo quieres obtener el valor de p\nt.test(bun_h, bun_m, var.equal = T)$p.value\n\nEl p-value = 0.002837017, quiere decir que hay muy baja probabilidad de que la diferencia de medias en los niveles de urea en sangre se deba a un error de muestreo o al azar. Consecuentemente, la hipótesis nula queda rechazada y aceptamos la hipótesis alternativa.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#análisis-de-componentes-principales",
    "href": "analisis_data.html#análisis-de-componentes-principales",
    "title": "2  Análisis de datos",
    "section": "2.5 Análisis de Componentes Principales",
    "text": "2.5 Análisis de Componentes Principales\nEste método de reducción dimensional incluye el análisis de valores propios (eigenvalues) y vectores propios (eigenvectors) de una matriz de covarianza o correlación. Sin embargo, para los propósitos de este curso aprenderás los conceptos básicos y necesarios para realizar este análisis multivariado. Te recomiendo que hagas una lectura a fondo de este tema utilizando la bibliografía que puedes encontrar en 2.7, si quieres utilizar este método para publicaciones científicas.\nPor lo pronto, empieza instalando los paquetes necesarios para esta sección e importando otro archivo hipotético de un segundo análisis de sangre que puedes descargara desde aquí.\n\nlibrary(factoextra)\nlibrary(ggfortify)\n\ndata_pca &lt;- read.csv(\"osos_hema_pca.csv\")\n\nHay muchos paquetes que incorporan funciones para realizar un PCA, pero para este curso introductorio sugiero que te familiarices con la función prcomp del paquete stats y algunas de factoextra para visualización.\n\nprcomp(data_pca[,1:4] , center= TRUE, scale=TRUE)\n\n¿Por qué no puedes correr este código? Recuerda que el set de datos que importamos, no fue limpiado, y al tener NA's, los análisis matemáticos no son posibles. Asegúrate de limpiarlo antes de proceder.\n\n# Limpia los datos\nclean_data &lt;- data_pca %&gt;% na.omit()\n\n# PCA\nosos_pca &lt;- prcomp(clean_data[, 1:4] , center= TRUE, scale=TRUE)\n\nEs muy importante tener en cuenta que los argumentos center y scale deben ser utilizados siempre. Así eliminarás sesgos sistemáticos asegurándote que la estructura de tus datos se basen en la covarianza/varianza, y además estandarizas los datos para evitar que la posible diferencia de escalas no afecten el cálculo.\nAhora puedes analizar los resultados del PCA de varias maneras y cada una de ellas te proporcionará con información valiosa para que entiendas los factores que contribuyen a la aparición de patrones y estructuras en los datos.\n\n2.5.1 Entendiendo el PCA\nEmpieza por ver un resumen del análisis.\n\nsummary(osos_pca)\n## Importance of components:\n##                           PC1    PC2     PC3     PC4\n## Standard deviation     1.6858 0.9817 0.43995 0.02920\n## Proportion of Variance 0.7105 0.2409 0.04839 0.00021\n## Cumulative Proportion  0.7105 0.9514 0.99979 1.00000\n\nPuedes notar que la proporción de varianza en el primer componente principal (PC1) es del 71.05% y en el PC2 es 24.09%, es decir que juntos explican el 95.14% de varianza total de los datos. Puedes visualizar qué componentes principales explican la mayor parte de la varianza, lo que te permitirá decidir cuantos componentes deberiás elegir para tus análisis posteriores.\n\n# Genera un scree plot\nfviz_eig(osos_pca, addlabels = TRUE,\n         barfill = \"gray70\", barcolor = \"black\")\n\n\n\n\n\n\n\n\nLos valores mostrados en el scree plot también puedes obtenerlos desde el objeto de esta manera:\n\nget_eigenvalue(osos_pca)\n##         eigenvalue variance.percent cumulative.variance.percent\n## Dim.1 2.8418189096      71.04547274                    71.04547\n## Dim.2 0.9637712653      24.09428163                    95.13975\n## Dim.3 0.1935573660       4.83893415                    99.97869\n## Dim.4 0.0008524591       0.02131148                   100.00000\n\nAhora sabes cuantos componentes deberías elegir, pero, ¿cuáles son las variables que están más fuertemente asociadas con cada componente principal?\n\nosos_pca$rotation\n##                      PC1          PC2        PC3          PC4\n## colesterol     0.5837967 -0.013514952 -0.3992519  0.706821577\n## trigliceridos  0.5838873 -0.002060441 -0.3984143 -0.707345345\n## proteina       0.4585282 -0.569329319  0.6823478 -0.004177978\n## bun           -0.3286472 -0.821995880 -0.4650435 -0.006954500\n\nPuedes visualizar esta contribución de la siguiente manera:\n\nfviz_pca_var(osos_pca,\n             col.var = \"contrib\",\n             gradient.cols = c(\"#440D54\", \"#39568C\", \"#54C667\"),\n             repel = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNota\n\n\n\nLos colores utilizados en este gráfico los he extraído del paquete viridis, que ayudan a mejorar la representación de los datos y son amigables con gente daltónica.\n\n\n\n\n2.5.2 Biplots\nAhora puedes crear un biplot, un tipo de gráfica típica de este análisis que contiene al score plot, es decir a los datos proyectas en dos componentes principales, y el loading plot, que representa la contribución de cada variable.\n\nfviz_pca_biplot(osos_pca,\n                geom.ind = \"point\",\n                pointshape = 21,\n                pointsize = 3.5,\n                fill.ind = clean_data$sexo,\n                label = \"var\",\n                repel = TRUE,\n                legend.title = \"Sexo osos\",\n                title = \"\") +\n  theme_light()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "analisis_data.html#t-de-student",
    "href": "analisis_data.html#t-de-student",
    "title": "2  Análisis de datos",
    "section": "2.4 T de Student",
    "text": "2.4 T de Student\nAhora que tienes evidencia de que los niveles de urea en sangre se aproximan a una distribución normal, puedes calcular el valor p. Primero necesitas subdividir al objeto nitrogenados.\n\n# Crea un objeto con los machos\nbun_m &lt;- nitrogenados %&gt;%\n            filter(sexo == \"macho\") %&gt;%\n                select(bun) %&gt;% unlist()\n\n# Ahora uno con las hembras\nbun_h &lt;- nitrogenados %&gt;%\n            filter(sexo == \"hembra\") %&gt;%\n                select(bun) %&gt;% unlist()\n\n\n\n\n\n\n\nEjercicio\n\n\n\n¿Cómo fueron almacenados los objetos col_m y col_h?. Lee sobre unlist en la sección de Ayuda.\n\n\nPuedes entonces realizar la prueba T de Student con una sola línea de comando.\n\nt.test(bun_h, bun_m, var.equal = T)\n\n#Si solo quieres obtener el valor de p\nt.test(bun_h, bun_m, var.equal = T)$p.value\n\nEl p-value = 0.002837017, quiere decir que hay muy baja probabilidad de que la diferencia de medias en los niveles de urea en sangre se deba a un error de muestreo o al azar. Consecuentemente, la hipótesis nula queda rechazada y aceptamos la hipótesis alternativa.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "index.html#expositores",
    "href": "index.html#expositores",
    "title": "Introducción a la Telemetría de Grandes Mamíferos",
    "section": "Expositores",
    "text": "Expositores\nEstudiantes y profesionales brindarán charlas para mostrar el trabajo que llevan a cabo en sus países.\n\nLas horas corresponden al horario de Ecuador (GMT -5)\n\n\n\n\n\n\n\nFecha\nExpositor\nTema\n\n\n\n\nMarzo 1, 2024 11:00 - 11:30\nDra. Diorene Smith Cabellos - Panamá\nBlindando de la extinción al perezoso pigmeo\n\n\nMarzo 4, 2024 11:00 - 11:30\nJorge Brito - Ecuador\nExplorando la diversidad de pequeños mamíferos no voladores en Ecuador: Avances y descubrimientos\n\n\nMarzo 5, 2024 10:30 - 11:00\nAngela Alviz - Colombia\nOcupación, patrones de actividad y abundancia relativa de la danta de tierras bajas (Tapirus terrestris) en Arauca, Colombia\n\n\nMarzo 5, 2024 11:00 - 11:30\nValentina López - Colombia\nPatrones intersexuales de la conducta de marcaje por olor del oso andino (Tremarctos ornatus) en el corredor biológico Guácharos-Puracé\n\n\nMarzo 7, 2024 10:30 - 11:00\nElias Condori - Perú\nMonitoreo de mamíferos con cámaras trampa en el valle de Koshñipata (zona de amortiguamiento del parque nacional del Manu)\n\n\nMarzo 7, 2024 11:00 - 11:30\nChristian Loaiza - Ecuador\nEl zorro de Séchura en Ecuador situación actual y estado de conservación",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "analisis_data.html#sec-est-basica-fuentes",
    "href": "analisis_data.html#sec-est-basica-fuentes",
    "title": "2  Análisis de datos",
    "section": "2.7 Fuentes",
    "text": "2.7 Fuentes\nEste capítulo fue tomado y adaptado de diversas fuentes, siendo R for Data Science, el curso gratis de edX Statistics and R, Linear Algebra for Data Science with examples in R, Plotting PCA, y Principal Component Methods in R: Practical Guide las más grandes influencias de este trabajo.\nTanto el análisis estadístico como la creación de gráficos utilizando ggplot2 son temas muy amplios para los cuales existen una amplia gama de recursos en internet. En cuanto a la parte estadística, he hecho una recopilación muy breve de libros que abordan estos temas, así como también sobre la investigación reproducible, su importancia, y como llevarla a cabo en R. Para acceder a estos recursos haz clic aquí.\nFinalmente, puedes profundizar más en el uso de ggplot2 ingresando a: Data Visualization with R , Top 50 ggplot2 Visualizations y Data visualization with ggplot2.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Análisis de datos</span>"
    ]
  },
  {
    "objectID": "areas_vida_1.html#section",
    "href": "areas_vida_1.html#section",
    "title": "4  Áreas de vida Parte I",
    "section": "",
    "text": "Estamos trabajando en este tutorial\n\n\n\n\n\n\nSilva, Inês, Christen H. Fleming, Michael J. Noonan, Jesse Alston, Cody Folta, William F. Fagan, and Justin M. Calabrese. 2022. “Autocorrelation-Informed Home Range Estimation: A Review and Practical Guide.” Methods in Ecology and Evolution 13 (3): 534–44. https://doi.org/10.1111/2041-210X.13786.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Áreas de vida Parte I</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#preparación-y-análisis-de-datos",
    "href": "datos_telemetricos.html#preparación-y-análisis-de-datos",
    "title": "3  Datos de telemetría satelital",
    "section": "3.2 Preparación y análisis de datos",
    "text": "3.2 Preparación y análisis de datos\nEs de suma importancia que estos pasos sean realizados de manera correcta, ya que cualquier error en la importación y limpieza de los datos nos puede traer grandes errores. A manera de ejercicio, he cambiado el formato del archivo original de MigratoryZebra.csv, tomado del curso Landscape and Analysis Modeling de The University of Tulsa, al que pueden acceder gratuitamente para profundizar más en los temas que trataremos en estas clases. Es siempre aconsejable tener una mirada general de nuestros datos antes de leerlos como objetos en R, ya que se debe utilizar la función adecuada para su lectura así que empecemos abriendo el archivo zebras.csv en un archivo de texto y miremos algunas características, como los separadores de columnas y los indicadores de decimales. Podemos ver que las columnas están separadas por un punto y coma “;”, y que los decimales se indican mediante una coma “,”.\n\n# Intenta leer el archivo con las siguientes funciones y mira cuales son las características de estos objetos mediante summary() y str()\n\ndata1 &lt;- read.csv(\"zebras.csv\")\ndata2 &lt;- read.csv2(\"zebras.csv\")\ndata3 &lt;- read.table(\"zebras.csv\", header = TRUE, na.strings = \"NA\",  sep=\";\")\n\nAhora activa el paquete readr (también parte de tidyverse) e intenta leer los datos mediante la función read_csv2()\n\ndata &lt;- read_csv2(\"zebras.csv\")\nsummary (data)\nstr(data)\n\nExtrae algunas columnas de interés para la clase de hoy y asignales un nombre más fácil de escribir.\n\nzebra &lt;- data[, c(\"event-id\", \"individual-local-identifier\",\n                \"location-long\", \"location-lat\", \"study-local-timestamp\")]\n\nzebra &lt;- zebra %&gt;%\n              rename(id = \"event-id\", identifier = \"individual-local-identifier\",\n              long = \"location-long\",\n              lat = \"location-lat\",\n              timestamp = \"study-local-timestamp\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#section",
    "href": "datos_telemetricos.html#section",
    "title": "3  Datos de telemetría satelital",
    "section": "3.3 ",
    "text": "3.3 \nHay que tener en cuenta que existen otros analisis como segmentacion FPT , etc que nos ayudan a predecir el comportamiento y el uso del espacio de un animal. Las areas de viida son solo uno de los tantos parametros q pueden obtenerse a partir de informacion satelital … etc xxxxxxx",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#preparación-de-los-datos",
    "href": "datos_telemetricos.html#preparación-de-los-datos",
    "title": "3  Datos de telemetría satelital",
    "section": "3.3 Preparación de los datos",
    "text": "3.3 Preparación de los datos\n\n3.3.1 Proyecciones\n``` \n\n\n\n\nAbrahms, Briana, Ellen O. Aikens, Jonathan B. Armstrong, William W. Deacy, Matthew J. Kauffman, and Jerod A. Merkle. 2021. “Emerging Perspectives on Resource Tracking and Animal Movement Ecology.” Trends in Ecology & Evolution 36 (4): 308–20. https://doi.org/10.1016/j.tree.2020.10.018.\n\n\nKays, Roland, Margaret C. Crofoot, Walter Jetz, and Martin Wikelski. 2015. “Terrestrial Animal Tracking as an Eye on Life and Planet.” Science 348 (6240): aaa2478. https://doi.org/10.1126/science.aaa2478.\n\n\nSilva, Inês, Christen H. Fleming, Michael J. Noonan, Jesse Alston, Cody Folta, William F. Fagan, and Justin M. Calabrese. 2022. “Autocorrelation-Informed Home Range Estimation: A Review and Practical Guide.” Methods in Ecology and Evolution 13 (3): 534–44. https://doi.org/10.1111/2041-210X.13786.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#importación-y-limpieza-de-datos-telemétricos",
    "href": "datos_telemetricos.html#importación-y-limpieza-de-datos-telemétricos",
    "title": "3  Datos de telemetría satelital",
    "section": "",
    "text": "IMPORTANTE\n\n\n\nEvita abrir cualquier archivo que será importado a R, utilizando Excel como primera opción. Utiliza editores de texto como Notepad o Notepad++.\n\n\n\n\n\nCaptura de pantalla de zebras.csv\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\nUtiliza tus habilidades y conocimiento en ggplot2 para realizar un gráfico similar al que acabas de realizar con plot.\n\n\n\n\n\n\n\n\n\n\nEjercicio\n\n\n\nUtiliza cualquier método para eliminar los datos de longitud y latitud faltantes en la fila 1802, y verifica que el proceso de limpieza de datos sea correcto.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#move2",
    "href": "datos_telemetricos.html#move2",
    "title": "3  Datos de telemetría satelital",
    "section": "3.4 move2",
    "text": "3.4 move2\nEste paquete es la continuación de move, y asi como sp, realizó una transición para incorporar funciones de sf. Para iniciar necesitarás convertir el data frame zebras a un objeto de clase move2, y además deberás ocuparte de otro problema, la transformación del tiempo.\n\ndos_zebras$timestamp &lt;- as.POSIXct(dos_zebras$timestamp, \"%Y-%m-%d %H:%M:%S\", tz=\"UTC\")\n\n\n\n\n\n\n\nImportante\n\n\n\nEstablecimos la zona horaria como UTC, que es la que usualmente usan como predeterminada los collares satelitales. Sin embargo deber ser cauteloso al momento de definir la zona horaria, y transformarla a tu zona de estudio, si es que fuese necesario. Esto lo puedes hacer con el paquete lubridate.\n\n\nMediante as.POSIXct, te has asegurado de transformar una columna que fue importada como caracter, y ahora la tienes en formato POSIXct, con el cual R maneja el tiempo. Una vez tengas tu set de datos con el formato adecuado, puedes empezar.\n\nlibrary(move2)\nlibrary(units)\n\ndos_zebras_move &lt;- mt_as_move2(dos_zebras, coords = c(\"long\", \"lat\"),\n            time_column = \"timestamp\", track_id_column = \"identifier\") %&gt;%\n            # en Mercator porque funciones no corren en Lambert\n            sf::st_set_crs(4326)\n\n# Estadísticas del objeto\nmt_n_tracks(dos_zebras_move)\n## [1] 2\n\n# ¿Cada cuantas horas se tomaron posiciones satelitales?\ntimeLags &lt;- set_units(mt_time_lags(dos_zebras_move), hours)\n\n# Distribution of time lags\ntimeLags_h &lt;- units::drop_units(timeLags) #hist is not compatible with time \"units\", we drop them\nhist(timeLags_h, breaks = 50, main=NA, xlab = \"Time lag in hours\")\n\n\n\n\n\n\n\n\nPuedes graficar la distribucion de puntos por individuo.\n\n# Grafico por individuos con ggplot2\nggplot() +\n  geom_sf(data = dos_zebras_move) +\n  geom_sf(data = mt_track_lines(dos_zebras_move), aes(color = identifier)) +\n  theme_light()\n\n\n\n\n\n\n\n\nAhora puedes anotar algunos parametros de movimiento como:\n\nAcimut o dirección angular: como sugiere su nombre estima la dirección engrados angulares en los cuales el animal se mueve.\nDesplazamiento cuadrado neto (NSD): mide el movimiento del animal como una distancia cuadrada neta y permite predecir si el animal mantiene un movimiento estacionario, migatorio. Mira la Figura 3.5.\nVelocidad: ten en cuenta que este paquete mide velocidad lineal entre un punto A y B, en un tiempo t0 y t1.\n\n\n\n\n\n\n\nFigura 3.5: Comportamiento teórico basado en la estimación del NSD. Tomado de Pretorius et al. (2020)\n\n\n\n\ndos_zebras_annot &lt;- dos_zebras_move %&gt;%\n                      mutate(azimuth = mt_azimuth(dos_zebras_move),\n                      speed = mt_speed(dos_zebras_move),\n                      turnangle = mt_turnangle(dos_zebras_move),\n                      NSD = (st_distance(dos_zebras_move,\n                      dos_zebras_move[1,]))^2)\n\nDebes tener en cuenta que es necesario agregar un límite en el cual tu infieras que el animal está en movimiento o no. Esto dependerá de tu conocimiento sobre el comportamiento de tu organismo de estudio, el terreno, el tipo de collar que utilizaste para tomar los puntos, entre otros factores. Así puedes establecer, por ahora, un limite de 5 m/min como indicador de movimiento en las zebras.\n\n# Cuando se mueven\nzebras_movimiento &lt;- dos_zebras_annot %&gt;% filter(speed &gt; set_units(5, \"m/min\"))\n\n\nzebras_movimiento$NSD &lt;- set_units(zebras_movimiento$NSD, \"km^2\")\nhead(zebras_movimiento$NSD)\n## Units: [km^2]\n##              [,1]\n## [1,] 7.856621e-04\n## [2,] 2.968707e+00\n## [3,] 2.310044e+01\n## [4,] 3.282908e+01\n## [5,] 2.785819e+01\n## [6,] 2.853610e+01\n\nggplot(zebras_movimiento, aes(x = mt_time(zebras_movimiento), y = NSD,\n  group = identifier)) +\n  geom_line() +\n  facet_grid(~identifier, scales = \"free_x\") +\n  labs(x = \"\", y =\"Desplazamiento cuadrático neto\") +\n  theme_bw()\n\n\n\n\n\n\n\n\n\nggplot(zebras_movimiento, aes(x = azimuth, y = speed)) +\n  geom_point(color= alpha(\"black\", 0.3)) +\n  scale_x_units(unit = \"degrees\", breaks = c(-2:2) * 90) +\n  scale_y_units(unit = \"km/h\") +\n  theme_linedraw()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTAREA\n\n\n\nGrafica la distribución de estas zebras sobre un mapa.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#fuentes",
    "href": "datos_telemetricos.html#fuentes",
    "title": "3  Datos de telemetría satelital",
    "section": "3.5 Fuentes",
    "text": "3.5 Fuentes\n\n\n\n\nGurarie, Eliezer, Chloe Bracis, Maria Delgado, Trevor D. Meckley, Ilpo Kojola, y C. Michael Wagner. 2016. «What is the animal doing? Tools for exploring behavioural structure in animal movements». Journal of Animal Ecology 85 (1): 69-84. https://doi.org/10.1111/1365-2656.12379.\n\n\nPretorius, Mattheuns, Lourens Leeuwner, Gareth Tate, Andre Botha, Michael Michael, Kaajial Durgapersad, y Kishaylin Chetty. 2020. «Movement patterns of lesser flamingos Phoeniconaias minor: nomadism or partial migration?» Wildlife Biology. https://doi.org/10.2981/wlb.00728.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#transformación-y-proyección-cartográfica",
    "href": "datos_telemetricos.html#transformación-y-proyección-cartográfica",
    "title": "3  Datos de telemetría satelital",
    "section": "3.2 Transformación y proyección cartográfica",
    "text": "3.2 Transformación y proyección cartográfica\nPara continuar y entender cual es el propósito de los siguientes pasos, primero debes entender que es una proyección cartográfica. En breve, la posición en el espacio tridimensional de un animal tomada mediante coordenadas decimales deben ser transformadas a un objeto bidimensional. Esta transformación viene acompañada de un gran problema como lo es la distorsión, y esta será más o menos evidente según el tipo de proyección que elijas.\nEl canal de YouTube Vox tiene un excelente video que muestra gráficamente este problema.\n\nEl paquete sp es el indicado para esta tarea ya que ofrece clases y métodos para manejar datos espaciales. Así, empezarás por transformar el objeto zebras.proj a un objeto de clase SpatialPointsDataFrame.\n\nlibrary(sp)\nlibrary(sf)\n\nzebras.proj &lt;- SpatialPointsDataFrame(coords = as.data.frame(cbind(zebras.proj$long, zebras.proj$lat)),\n                data = zebras.proj,\n                proj4string = CRS(\"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\"))\n\nPara entender el código que antecede a la función proj4string primero te debes preguntar, ¿qué significa CRS, y qué argumentos contiene esta función? proj4string no es nada más que una librería que dispone de métodos que permiten la transformación entre diferentes sistemas de coordenadas de referencia (CRS).\nCRS permite determinar la ubicación de un punto de una manera estandarizada, utilizando uno o más números que representan tanto su posición vertical como horizontal. Para lograr esto, utiliza como referencia un elipsoide que es una representación matemática de la Tierra. Una vez definido el sistema de coordenadas, datum define la posición y orientación del elipsoide de referencia en relación con el centro de la Tierra y el meridiano usado como longitud cero, el meridiano principal. Investiga sobre el significado de WGS84.\nComo ya deberia ser habitual para ti, analiza tu objeto antes de proseguir. ¿Qué sucedió con zebras.proj? Aplica funciones que has aprendido para analizar este nueva clase de objeto.\n\n\n\n\n\n\nPrecaución\n\n\n\nHe decidido mostrar el código antiguo de definir la proyección para mejorar la comprensión de lo que sucede tras escenas del código. Sin embargo proj4string ahora debe definirse como CRS(SRS_string = \"EPSG:4326\")\n\n\n\nclass(zebras.proj)\n## [1] \"SpatialPointsDataFrame\"\n## attr(,\"package\")\n## [1] \"sp\"\nsummary(zebras.proj)\n## Object of class SpatialPointsDataFrame\n## Coordinates:\n##          min       max\n## V1  23.52338  25.26070\n## V2 -20.81156 -19.38558\n## Is projected: FALSE \n## proj4string : [+proj=longlat +datum=WGS84 +no_defs]\n## Number of points: 8914\n## Data attributes:\n##   identifier             long            lat          timestamp        \n##  Length:8914        Min.   :23.52   Min.   :-20.81   Length:8914       \n##  Class :character   1st Qu.:23.61   1st Qu.:-20.59   Class :character  \n##  Mode  :character   Median :24.88   Median :-20.44   Mode  :character  \n##                     Mean   :24.47   Mean   :-20.15                     \n##                     3rd Qu.:25.00   3rd Qu.:-19.44                     \n##                     Max.   :25.26   Max.   :-19.39\n\nYa has verificado la transformación de las CRS, sin embargo, estos siguen siendo puntos en un mapa representados por medidas angulares. ¿De qué manera podemos medir la distancia entre ellos para poder calcular el área descrita por los puntos posteriormente? Transformando esta proyección a un sistema basado en metros.\n\nzebras.transf &lt;- spTransform(zebras.proj,\n                  CRS(\"+proj=lcc +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs\"))\n\nEsta CRS es una proyección cónica y representa a la forma más precisamente que a un área. Esta transformación nos da como resultado un mapa matemático de coordenadas esféricas en un plano bidimensional, cuyas unidades pueden son expresadas en metros. Con todo esto en mente, ya podemos plotear este objeto proyectado de clase SpatialPointsDataFrame.\n\n\n\n\n# ¿Qué diferencia tiene este grafico con el anterior?\nplot(zebras.transf, pch = 20, col = c(\"#440D54\", \"#3CBB75\"), axes=TRUE)\n\n\n\n\n\n\n\n\n\n\nFigura 3.4: Zebras extraídas del data frame zebra observadas mediante una proyección cónica y transformada a un sistema basado en metros\n\n\n\n¿Cuál es la diferencia entre la Figura 3.4 y Figura 3.3 ?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#importación-limpieza-y-visualización-de-datos-telemétricos",
    "href": "datos_telemetricos.html#importación-limpieza-y-visualización-de-datos-telemétricos",
    "title": "3  Datos de telemetría satelital",
    "section": "",
    "text": "IMPORTANTE\n\n\n\nEvita abrir cualquier archivo que será importado a R, utilizando Excel como primera opción. Utiliza editores de texto como Notepad o Notepad++.\n\n\n\n\n\n\n\n\nFigura 3.1: Captura de pantalla de zebras.csv\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Cambia el valor de pch y mira que sucede con el gráfico\nplot(zebras[, c(\"long\", \"lat\")], pch = 20)\n\n\n\n\n\n\n\n\n\n\nFigura 3.2: Distribución espacial de todos los individuos en el data frame zebras\n\n\n\n\n\n\n\n\n\n\n#cambia el valor de pch y mira que sucede con el gráfico\nplot(dos_zebras[, c(\"long\", \"lat\")], pch = 20, col = c(\"#440D54\", \"#3CBB75\"))\nlegend(\"topright\", legend = c(\"Z3864\", \"Z6405\"),\n      fill = c(\"#440D54\", \"#3CBB75\"),\n      pch = 20, box.lty = 0)\n\n\n\n\n\n\n\n\n\n\nFigura 3.3: Distribución espacial de dos zebras extraídas del data frame zebras\n\n\n\n\n\n\n\n\n\nTarea\n\n\n\nUtiliza tus habilidades y conocimiento en ggplot2 para realizar un gráfico similar al que acabas de realizar con plot.\n\n\n\n\n\n\n\n\n\n\nEjercicio\n\n\n\nUtiliza cualquier método para eliminar los datos de longitud y latitud faltantes en la fila 1802, y verifica que el proceso de limpieza de datos sea correcto.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#adehabitathr",
    "href": "datos_telemetricos.html#adehabitathr",
    "title": "3  Datos de telemetría satelital",
    "section": "3.3 adehabitatHR",
    "text": "3.3 adehabitatHR\nEl paquete adeHabitatHR es uno de cuatro paquetes que hace unos años formaban parte del paquete ya deprecado adehabitat, y se especializa en el análisis de áreas de vida. Este paquete, sin embargo, se enfrenta a un riesgo a futuro ya que otros paquetes utilizados dentro de la disciplina del análisis espacial, dependían en gran medida de los paquetes raster, rgdal, rgeos, y sp, que fueron reemplazados en el 2023 por sf y terra. sp es el único que se adaptó a esta transición y adoptó funciones del paquete sf Sin embargo, adehabitatHR no se adaptó a esta transformación y depende de la instalación de estos paquetes que ya no reciben mantenimiento.\nA pesar de esto,",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "areas_vida_1.html#adehabitathr",
    "href": "areas_vida_1.html#adehabitathr",
    "title": "4  Áreas de vida Parte I",
    "section": "",
    "text": "4.1.1 Home range zebras\nContinuando con el objeto zebras.transf que generaste en la sección Section 3.2\n\n\n\n\nAbrahms, Briana, Ellen O. Aikens, Jonathan B. Armstrong, William W. Deacy, Matthew J. Kauffman, and Jerod A. Merkle. 2021. “Emerging Perspectives on Resource Tracking and Animal Movement Ecology.” Trends in Ecology & Evolution 36 (4): 308–20. https://doi.org/10.1016/j.tree.2020.10.018.\n\n\nKays, Roland, Margaret C. Crofoot, Walter Jetz, and Martin Wikelski. 2015. “Terrestrial Animal Tracking as an Eye on Life and Planet.” Science 348 (6240): aaa2478. https://doi.org/10.1126/science.aaa2478.\n\n\nSilva, Inês, Christen H. Fleming, Michael J. Noonan, Jesse Alston, Cody Folta, William F. Fagan, and Justin M. Calabrese. 2022. “Autocorrelation-Informed Home Range Estimation: A Review and Practical Guide.” Methods in Ecology and Evolution 13 (3): 534–44. https://doi.org/10.1111/2041-210X.13786.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Áreas de vida Parte I</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#análisis-de-trayectorias",
    "href": "datos_telemetricos.html#análisis-de-trayectorias",
    "title": "3  Datos de telemetría satelital",
    "section": "3.3 Análisis de trayectorias",
    "text": "3.3 Análisis de trayectorias\nDebes tener en cuenta que la limpieza de los sets de datos no es el único paso a seguir en el análisis espacial, también debes explorar métodos de segmentación o partición para poder discernir cambios en la conducta o trayectoria de un animal (Gurarie et al. (2016)). Según la pregunta de investigación que tengas debes indagar más en otros métodos como First Passage Time (FPT), step selection function, etc.\nAquí, verás brevemente como puedes obtener información sobre la trayectoria de las zebras que extrajimos previamente.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  },
  {
    "objectID": "datos_telemetricos.html#sec-transf-proy",
    "href": "datos_telemetricos.html#sec-transf-proy",
    "title": "3  Datos de telemetría satelital",
    "section": "3.2 Transformación y proyección cartográfica",
    "text": "3.2 Transformación y proyección cartográfica\nPara continuar y entender cual es el propósito de los siguientes pasos, primero debes entender que es una proyección cartográfica. En breve, la posición en el espacio tridimensional de un animal tomada mediante coordenadas decimales deben ser transformadas a un objeto bidimensional. Esta transformación viene acompañada de un gran problema como lo es la distorsión, y esta será más o menos evidente según el tipo de proyección que elijas.\nEl canal de YouTube Vox tiene un excelente video que muestra gráficamente este problema.\n\nEl paquete sp es el indicado para esta tarea ya que ofrece clases y métodos para manejar datos espaciales. Así, empezarás por transformar el objeto zebras.proj a un objeto de clase SpatialPointsDataFrame.\n\nlibrary(sp)\nlibrary(sf)\n\nzebras.proj &lt;- SpatialPointsDataFrame(coords = as.data.frame(cbind(zebras.proj$long, zebras.proj$lat)),\n                data = zebras.proj,\n                proj4string = CRS(\"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\"))\n\nPara entender el código que antecede a la función proj4string primero te debes preguntar, ¿qué significa CRS, y qué argumentos contiene esta función? proj4string no es nada más que una librería que dispone de métodos que permiten la transformación entre diferentes sistemas de coordenadas de referencia (CRS).\nCRS permite determinar la ubicación de un punto de una manera estandarizada, utilizando uno o más números que representan tanto su posición vertical como horizontal. Para lograr esto, utiliza como referencia un elipsoide que es una representación matemática de la Tierra. Una vez definido el sistema de coordenadas, datum define la posición y orientación del elipsoide de referencia en relación con el centro de la Tierra y el meridiano usado como longitud cero, el meridiano principal. Investiga sobre el significado de WGS84.\nComo ya deberia ser habitual para ti, analiza tu objeto antes de proseguir. ¿Qué sucedió con zebras.proj? Aplica funciones que has aprendido para analizar este nueva clase de objeto.\n\n\n\n\n\n\nPrecaución\n\n\n\nHe decidido mostrar el código antiguo de definir la proyección para mejorar la comprensión de lo que sucede tras escenas del código. Sin embargo proj4string ahora debe definirse como CRS(SRS_string = \"EPSG:4326\")\n\n\n\nclass(zebras.proj)\n## [1] \"SpatialPointsDataFrame\"\n## attr(,\"package\")\n## [1] \"sp\"\nsummary(zebras.proj)\n## Object of class SpatialPointsDataFrame\n## Coordinates:\n##          min       max\n## V1  23.52338  25.26070\n## V2 -20.81156 -19.38558\n## Is projected: FALSE \n## proj4string : [+proj=longlat +datum=WGS84 +no_defs]\n## Number of points: 8914\n## Data attributes:\n##   identifier             long            lat          timestamp        \n##  Length:8914        Min.   :23.52   Min.   :-20.81   Length:8914       \n##  Class :character   1st Qu.:23.61   1st Qu.:-20.59   Class :character  \n##  Mode  :character   Median :24.88   Median :-20.44   Mode  :character  \n##                     Mean   :24.47   Mean   :-20.15                     \n##                     3rd Qu.:25.00   3rd Qu.:-19.44                     \n##                     Max.   :25.26   Max.   :-19.39\n\nYa has verificado la transformación de las CRS, sin embargo, estos siguen siendo puntos en un mapa representados por medidas angulares. ¿De qué manera podemos medir la distancia entre ellos para poder calcular el área descrita por los puntos posteriormente? Transformando esta proyección a un sistema basado en metros.\n\nzebras.transf &lt;- spTransform(zebras.proj,\n                  CRS(\"+proj=lcc +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs\"))\n\nEsta CRS es una proyección cónica y representa a la forma más precisamente que a un área. Esta transformación nos da como resultado un mapa matemático de coordenadas esféricas en un plano bidimensional, cuyas unidades pueden son expresadas en metros. Con todo esto en mente, ya podemos plotear este objeto proyectado de clase SpatialPointsDataFrame.\n\n\n\n\n# ¿Qué diferencia tiene este grafico con el anterior?\nplot(zebras.transf, pch = 20, col = c(\"#440D54\", \"#3CBB75\"), axes=TRUE)\n\n\n\n\n\n\n\n\n\n\nFigura 3.4: Zebras extraídas del data frame zebra observadas mediante una proyección cónica y transformada a un sistema basado en metros\n\n\n\n¿Cuál es la diferencia entre la Figura 3.4 y Figura 3.3 ?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datos de telemetría satelital</span>"
    ]
  }
]
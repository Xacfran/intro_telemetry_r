---
format:
  html:
    toc: true
    toc-title: "Contenidos"
    toc-expand: 1
    code-overflow: wrap
editor_options:
  markdown:
    wrap: sentence
    canonical: true
theme: cosmo
lang: es
---
```{r}
#| include: false
source("_common.R")

data <- read_csv2("docs/datos/zebras.csv")
zebras <- data[, c("event-id", "individual-local-identifier",
                "location-long", "location-lat", "study-local-timestamp")]
dos_zebras <- zebras %>%
              rename(id = "event-id", identifier = "individual-local-identifier",
              long = "location-long",
              lat = "location-lat",
              timestamp = "study-local-timestamp") |>
          filter(identifier == "Z3864" | identifier == "Z6405") |>
          dplyr::select(identifier, long, lat, timestamp) |> na.omit()
zebras.proj <- SpatialPointsDataFrame(coords = as.data.frame(cbind(dos_zebras$long, dos_zebras$lat)),
                data = dos_zebras,
                proj4string = CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
zebras.transf <- spTransform(zebras.proj,
                  CRS("+proj=lcc +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
```

# Áreas de vida {#sec-areas-vida}

La estimación de áreas de vida es una parte fundamental, pero no la única, en el estudio de la ecología y etología de los animales, y los artículos científicos de @kays_terrestrial_2015, @abrahms_emerging_2021, y @silva_autocorrelation-informed_2022 son una excelente fuente de información si estás involucrándote en el mundo de la ecología de movimiento. Si bien existen diversos métodos por los cuales se pueden estimar dichas áreas, en este módulo aprenderás sobre métodos tradicionales ampliamente utilizados y que serán comparados más adelante con nuevos métodos en el paquete _ctmm_.

## _adehabitatHR_

El paquete [_adeHabitatHR_](https://cran.r-project.org/web/packages/adehabitatHR/vignettes/adehabitatHR.pdf) es uno de cuatro paquetes que hace unos años formaban parte del paquete ya deprecado _adehabitat_, y se especializa en el análisis de áreas de vida. Este paquete, sin embargo, se enfrenta a un riesgo a futuro ya que otros paquetes utilizados dentro de la disciplina del análisis espacial, dependían en gran medida de los paquetes _raster_, _rgdal_, _rgeos_, y _sp_, que fueron reemplazados en el 2023 por _sf_ y _terra_. _sp_ es el único que se adaptó a esta transición y adoptó funciones del paquete _sf_ Sin embargo, _adehabitatHR_ no se adaptó a esta transformación y depende de la instalación de estos paquetes que ya no reciben mantenimiento.

A pesar de esto, aprender sobre _adeHabitatHR_ es aún necesario ya que no existe, a la fecha, un paquete que incorpore todas las utilidades que éste lo hace.

Ahora estimarás el área de vida de las zebras que fueron extraídas en el objeto `zebras.transf` en la @sec-transf-proy.

```{r}
#| code-fold: true
#| code-summary: "Obten el objeto `zebras.transf`"

zebras.transf <- spTransform(zebras.proj,
                  CRS("+proj=lcc +lat_1=20 +lat_2=-23 +lat_0=0 +lon_0=25 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"))
```

## Minimum Convex Polygon (MCP)

### Zebras en África
Este método es de los más sencillo para dibujar los límites de distribución de un animal. Aunque su uso original Carl O. Mohr (1947) fue destinado a la identificación de animales recapturados en una malla de captura.

El uso del MCP es limitado ya que este describe el alcance de la distribución de ubicaciones de un individuo, mas no la verdadera área de vida del animal bajo estudio. Para una discusión más detallada sobre esto puedes leer @signer_fresh_2021, y un debate profundo sobre rangos y ocurrencia de distribución en @fleming_estimating_2016.

A pesar de lo anteriormente mencionado, obtener el área del polígono y el poder ubicarlo sobre un mapa, nos permite observar a _grosso modo_ el espacio y hábitat que ocupa cierto ejemplar.

```{r}
library(adehabitatHR)
library(sf)
zebras.mcp <- mcp(zebras.transf[, "identifier"], percent= 100,
              unin="m", unout= "ha")
```

:::::: {.callout-note}
## Ejercicio
Ahora intenta con distintos porcentajes y observa las diferencias en tamaños de área.
:::

Si bien puedes utilizar funciones base de R para graficar estos polígonos, aprovecha la interacción de estos paquetes con _sf_ y _ggplot2_ para obtener un gráfico más estético.

```{r}
library(ggplot2)

ggplot() +
      geom_sf(data = st_as_sf(zebras.mcp), aes(fill = id),
              alpha = 0.2) +
      geom_sf(data = st_as_sf(zebras.transf), aes(colour = identifier)) +
      coord_sf() +
      theme_bw()
```

También puedes exportar estos polígonos con extensión `kml` para que puedas importarlos en Google Earth o cualquier software de tu preferencia.
```{r eval = FALSE}
st_write(st_as_sf(zebras.mcp), "zebras.kml", delete_layer = TRUE)
```

### Animales hipotéticos

Como caso de estudio, e intentando que mejores en el flujo de trabajo de estos análisis, creé un set de datos de tres mamíferos hipotéticos en la zona Norte de Loreto - Perú, y lo puedes [descargar aquí](https://mega.nz/folder/VwVQEbJK#lxYXI88_90s6hUihhwNXgg).

```{r include = FALSE}
mamiferos <- read.csv("docs/datos/mamiferos.csv")
```

```{r eval = FALSE}
mamiferos <- read.csv("mamiferos.csv")
```

Como siempre, haz una exploración rápida de este objeto y grafica los puntos satelitales rápidamente.

```{r}
plot(mamiferos[, c("longitude", "latitude")], pch=20)
```

:::::: {.callout-note}
## Ejercicio
Realiza una limpieza de este set de datos, elimina outliers y datos faltantes, y crea un objeto que contenga únicamente a "juancho". Finalmente, verifica que el proceso haya sido exitoso.
:::

```{r include = FALSE}
# Verificación visual
library(plotly)

mamiferos_outliers <- mamiferos %>%
  ggplot(aes(x= longitude, y=latitude, colour = name))+
  geom_point(alpha = 0.5)

ggplotly(mamiferos_outliers)

#Limpiar el data frame
juancho <- mamiferos[-which(mamiferos$longitude < -76),] |>
                na.omit() |>
                filter(name == "juancho")

summary(juancho)
```

Ahora que has filtrado el set de datos, ya puedes realizar la proyeccion, transformación y cálculo del área de vida y núcleo de juancho.

```{r}
juancho.proj <- SpatialPointsDataFrame(coords = as.data.frame(cbind
                        (juancho$longitude, juancho$latitude)),
                        data = juancho, proj4string = CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
```

A diferencia de las zebras, sabemos que nuestro lugar de muestreo es pequeño, y en una región tropical, por ende necesitamos un método de proyección adecuado. Entre tantos métodos existentes, ¿cuál elegirías?
En estos casos, lo aconsejable es utilizar [Universal Transverse Mercator](https://gisgeography.com/utm-universal-transverse-mercator-projection/) (UTM). No obstante, para hacer uso de este método de proyección, aún nos falta conocer un dato importante, la zona y el hemisferio.

Podemos copiar y pegar cualquiera de los puntos de nuestro set de datos en [esta página](http://rcn.montana.edu/resources/Converter.aspx) para poder conocer la información faltante.

```{r}
juancho.transf <- spTransform(juancho.proj,
                           CRS("+proj=utm +south +zone=18 +ellps=WGS84"))
```

Si deseas conocer las coordenadas UTM de todos los puntos, puedes crear un nuevo objeto y ejecutar las siguientes líneas.
```{r}
juancho.utm <- coordinates(juancho.transf)
head(juancho.utm)
```

:::::: {.callout-note}
## Ejercicio
Estima el área de vida (90%) y núcleo (50%) de juancho mediante el método MCP.
:::

## Kernel Density Estimate (KDE)

En KDE, una colina tri-dimensional o kernel es formada junto a cada punto, la forma y altura de esta colina depende del ancho de banda (_bandwidth_).
En este curso calcularás el KDE mediante el “_fixed kernel_” o href, “_least squares cross-validation_” o lcsv, e intentarás ajustar el bandwidth manualmente.
La teoría sobre estos métodos, sus pros y contras pueden ser encontrados en estos links: [1], [2].

### _Fixed kernel_ (href)

```{r}
juancho.khref <- kernelUD(juancho.transf[, "name"], h = "href")

# Observa este raster
image(juancho.khref)
```

Si quieres exportarlo para su uso en otros softwares como ArcGis puedes seguir estos pasos.

```{r warnings = FALSE, output = FALSE}
juanchopix <- estUDm2spixdf(juancho.khref)
st_write(st_as_sf(juanchopix), "juancho.shp", delete_layer = TRUE)
# Mira otros formatos disponibles con st_drivers()
```

También puedes plotearlo en R.
```{r}
# Tambien se puede plotear en R
plot(juanchopix)
plot(juancho.transf, add=T, cex=0.1)
```

Utilizando estos objetos, ya puedes estimar el área de vida de juancho mediante el método KDE.

```{r}
#Estimo el area usando el objeto juancho.khref segun una secuencia de porcentajes
kernel.area(juancho.khref, percent = seq (20,95,5),
            unin="m", unout="ha")
```

Ahora estima el home range desde el objeto `juancho.khref` que creaste anteriormente.

```{r}
#Obtengo las lineas para el plot final
juancho.KDE95 <- getverticeshr(juancho.khref, percent= 95)
```

:::::: {.callout-note}
## Ejericicio
La función `getvolumeUD` también te permite calcular el área de vida, pero ¿cuál crees que sea la diferencia entre ambos métodos?
:::

## Fuentes

Puedes utilizar el [manual de _adehabitatHR_](https://cran.r-project.org/web/packages/adehabitatHR/vignettes/adehabitatHR.pdf) para resolver los ejercicios de este tutorial y puedes explorar más funciones que ofrece este paquete.